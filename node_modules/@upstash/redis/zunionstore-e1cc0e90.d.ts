import { HttpClient } from './http';

/**
 * Command offers default (de)serialization and the exec method to all commands.
 *
 * TData represents what the user will enter or receive,
 * TResult is the raw data returned from upstash, which may need to be transformed or parsed.
 */
declare class Command<TData, TResult> {
    readonly command: string[];
    deserialize: (result: TResult) => TData;
    /**
     * Create a new command instance.
     *
     * You can define a custom `deserialize` function. By default we try to deserialize as json.
     */
    constructor(command: (string | unknown)[], opts?: {
        deserialize?: (result: TResult) => TData;
    });
    /**
     * Execute the command using a client.
     */
    exec(client: HttpClient): Promise<TData>;
}

declare type NonEmptyArray<T> = [T, ...T[]];
declare type CommandArgs<TCommand extends new (...args: any) => any> = ConstructorParameters<TCommand>;

declare type ScanCommandOptions = {
    match?: string;
    count?: number;
};
/**
 * @see https://redis.io/commands/scan
 */
declare class ScanCommand extends Command<[number, string[]], [number, string[]]> {
    constructor(cursor: number, opts?: ScanCommandOptions);
}

declare type SetCommandOptions = ({
    ex: number;
    px?: never;
} | {
    ex?: never;
    px: number;
} | {
    ex?: never;
    px?: never;
}) & ({
    nx: true;
    xx?: never;
} | {
    xx: true;
    nx?: never;
} | {
    xx?: never;
    nx?: never;
});
/**
 * @see https://redis.io/commands/set
 */
declare class SetCommand<TData, TResult = "OK"> extends Command<TData, TResult> {
    constructor(key: string, value: TData, opts?: SetCommandOptions);
}

declare type Type = "string" | "list" | "set" | "zset" | "hash" | "none";
/**
 * @see https://redis.io/commands/type
 */
declare class TypeCommand extends Command<Type, Type> {
    constructor(key: string);
}

/**
 * @see https://redis.io/commands/unlink
 */
declare class UnlinkCommand extends Command<number, number> {
    constructor(...keys: string[]);
}

declare type ZAddCommandOptions = ({
    nx: true;
    xx?: never;
} | {
    nx?: never;
    xx: true;
} | {
    nx?: never;
    xx?: never;
}) & {
    ch?: true;
};
declare type ZAddCommandOptionsWithIncr = ZAddCommandOptions & {
    incr: true;
};
declare type ScoreMember<TData> = {
    score: number;
    member: TData;
};
/**
 * @see https://redis.io/commands/zadd
 */
declare class ZAddCommand<TData = string> extends Command<number | null, number | null> {
    constructor(key: string, scoreMember: ScoreMember<TData>, ...scoreMemberPairs: ScoreMember<TData>[]);
    constructor(key: string, opts: ZAddCommandOptions | ZAddCommandOptionsWithIncr, ...scoreMemberPairs: [ScoreMember<TData>, ...ScoreMember<TData>[]]);
}

declare type ZInterStoreCommandOptions = {
    aggregate?: "sum" | "min" | "max";
} & ({
    weight: number;
    weights?: never;
} | {
    weight?: never;
    weights: number[];
} | {
    weight?: never;
    weights?: never;
});
/**
 * @see https://redis.io/commands/zInterstore
 */
declare class ZInterStoreCommand extends Command<number, number> {
    constructor(destination: string, numKeys: 1, key: string, opts?: ZInterStoreCommandOptions);
    constructor(destination: string, numKeys: number, keys: string[], opts?: ZInterStoreCommandOptions);
}

declare type ZRangeCommandOptions = {
    withScores?: boolean;
};
/**
 * @see https://redis.io/commands/zrange
 */
declare class ZRangeCommand<TData extends unknown[]> extends Command<TData, string[]> {
    constructor(key: string, min: number | `(${number}`, max: number | `(${number}`, opts?: ZRangeCommandOptions);
}

declare type ZUnionStoreCommandOptions = {
    aggregate?: "sum" | "min" | "max";
} & ({
    weight: number;
    weights?: never;
} | {
    weight?: never;
    weights: number[];
} | {
    weight?: never;
    weights?: never;
});
/**
 * @see https://redis.io/commands/zunionstore
 */
declare class ZUnionStoreCommand extends Command<number, number> {
    constructor(destination: string, numKeys: 1, key: string, opts?: ZUnionStoreCommandOptions);
    constructor(destination: string, numKeys: number, keys: string[], opts?: ZUnionStoreCommandOptions);
}

export { CommandArgs as C, NonEmptyArray as N, ScanCommandOptions as S, Type as T, UnlinkCommand as U, ZAddCommandOptions as Z, SetCommandOptions as a, ScoreMember as b, ZAddCommandOptionsWithIncr as c, ZInterStoreCommandOptions as d, ZRangeCommandOptions as e, ZUnionStoreCommandOptions as f, Command as g, ScanCommand as h, SetCommand as i, TypeCommand as j, ZAddCommand as k, ZInterStoreCommand as l, ZRangeCommand as m, ZUnionStoreCommand as n };
