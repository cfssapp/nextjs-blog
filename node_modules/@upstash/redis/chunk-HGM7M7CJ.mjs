import {
  UpstashError
} from "./chunk-7YUZYRJS.mjs";

// pkg/util.ts
function parseRecursive(obj) {
  const parsed = Array.isArray(obj) ? obj.map((o) => {
    try {
      return parseRecursive(o);
    } catch {
      return o;
    }
  }) : JSON.parse(obj);
  if (typeof parsed === "number" && parsed.toString() != obj) {
    return obj;
  }
  return parsed;
}
function parseResponse(result) {
  try {
    return parseRecursive(result);
  } catch {
    return result;
  }
}

// pkg/commands/command.ts
var Command = class {
  constructor(command, opts) {
    var _a;
    this.command = command.map((c) => typeof c === "string" ? c : JSON.stringify(c));
    this.deserialize = (_a = opts == null ? void 0 : opts.deserialize) != null ? _a : parseResponse;
  }
  async exec(client) {
    const { result, error } = await client.request({
      body: this.command
    });
    if (error) {
      throw new UpstashError(error);
    }
    if (typeof result === "undefined") {
      throw new Error(`Request did not return a result`);
    }
    return this.deserialize(result);
  }
};

// pkg/commands/append.ts
var AppendCommand = class extends Command {
  constructor(key, value) {
    super(["append", key, value]);
  }
};

// pkg/commands/bitcount.ts
var BitCountCommand = class extends Command {
  constructor(key, start, end) {
    const command = ["bitcount", key];
    if (typeof start === "number") {
      command.push(start);
    }
    if (typeof end === "number") {
      command.push(end);
    }
    super(command);
  }
};

// pkg/commands/bitop.ts
var BitOpCommand = class extends Command {
  constructor(op, destinationKey, sourceKey, ...sourceKeys) {
    super(["bitop", op, destinationKey, sourceKey, ...sourceKeys]);
  }
};

// pkg/commands/bitpos.ts
var BitPosCommand = class extends Command {
  constructor(key, start, end) {
    super(["bitpos", key, start, end]);
  }
};

// pkg/commands/dbsize.ts
var DBSizeCommand = class extends Command {
  constructor() {
    super(["dbsize"]);
  }
};

// pkg/commands/decr.ts
var DecrCommand = class extends Command {
  constructor(key) {
    super(["decr", key]);
  }
};

// pkg/commands/decrby.ts
var DecrByCommand = class extends Command {
  constructor(key, decrement) {
    super(["decrby", key, decrement]);
  }
};

// pkg/commands/del.ts
var DelCommand = class extends Command {
  constructor(...keys) {
    super(["del", ...keys]);
  }
};

// pkg/commands/echo.ts
var EchoCommand = class extends Command {
  constructor(message) {
    super(["echo", message]);
  }
};

// pkg/commands/exists.ts
var ExistsCommand = class extends Command {
  constructor(...keys) {
    super(["exists", ...keys]);
  }
};

// pkg/commands/expire.ts
var ExpireCommand = class extends Command {
  constructor(key, seconds) {
    super(["expire", key, seconds]);
  }
};

// pkg/commands/expireat.ts
var ExpireAtCommand = class extends Command {
  constructor(key, unix) {
    super(["expireat", key, unix]);
  }
};

// pkg/commands/flushall.ts
var FlushAllCommand = class extends Command {
  constructor(opts) {
    const command = ["flushall"];
    if (opts == null ? void 0 : opts.async) {
      command.push("async");
    }
    super(command);
  }
};

// pkg/commands/flushdb.ts
var FlushDBCommand = class extends Command {
  constructor(opts) {
    const command = ["flushdb"];
    if (opts == null ? void 0 : opts.async) {
      command.push("async");
    }
    super(command);
  }
};

// pkg/commands/get.ts
var GetCommand = class extends Command {
  constructor(key) {
    super(["get", key]);
  }
};

// pkg/commands/getbit.ts
var GetBitCommand = class extends Command {
  constructor(key, offset) {
    super(["getbit", key, offset]);
  }
};

// pkg/commands/getrange.ts
var GetRangeCommand = class extends Command {
  constructor(key, start, end) {
    super(["getrange", key, start, end]);
  }
};

// pkg/commands/getset.ts
var GetSetCommand = class extends Command {
  constructor(key, value) {
    super(["getset", key, value]);
  }
};

// pkg/commands/hdel.ts
var HDelCommand = class extends Command {
  constructor(key, field) {
    super(["hdel", key, field]);
  }
};

// pkg/commands/hexists.ts
var HExistsCommand = class extends Command {
  constructor(key, field) {
    super(["hexists", key, field]);
  }
};

// pkg/commands/hget.ts
var HGetCommand = class extends Command {
  constructor(key, field) {
    super(["hget", key, field]);
  }
};

// pkg/commands/hgetall.ts
function deserialize(result) {
  if (result.length === 0) {
    return null;
  }
  const obj = {};
  while (result.length >= 2) {
    const key = result.shift();
    const value = result.shift();
    try {
      obj[key] = JSON.parse(value);
    } catch {
      obj[key] = value;
    }
  }
  return obj;
}
var HGetAllCommand = class extends Command {
  constructor(key) {
    super(["hgetall", key], { deserialize: (result) => deserialize(result) });
  }
};

// pkg/commands/hincrby.ts
var HIncrByCommand = class extends Command {
  constructor(key, field, increment) {
    super(["hincrby", key, field, increment]);
  }
};

// pkg/commands/hincrbyfloat.ts
var HIncrByFloatCommand = class extends Command {
  constructor(key, field, increment) {
    super(["hincrbyfloat", key, field, increment]);
  }
};

// pkg/commands/hkeys.ts
var HKeysCommand = class extends Command {
  constructor(key) {
    super(["hkeys", key]);
  }
};

// pkg/commands/hlen.ts
var HLenCommand = class extends Command {
  constructor(key) {
    super(["hlen", key]);
  }
};

// pkg/commands/hmget.ts
function deserialize2(fields, result) {
  if (result.length === 0 || result.every((field) => field === null)) {
    return null;
  }
  const obj = {};
  for (let i = 0; i < fields.length; i++) {
    try {
      obj[fields[i]] = JSON.parse(result[i]);
    } catch {
      obj[fields[i]] = result[i];
    }
  }
  return obj;
}
var HMGetCommand = class extends Command {
  constructor(key, ...fields) {
    super(["hmget", key, ...fields], {
      deserialize: (result) => deserialize2(fields, result)
    });
  }
};

// pkg/commands/hmset.ts
var HMSetCommand = class extends Command {
  constructor(key, kv) {
    super(["hmset", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])]);
  }
};

// pkg/commands/hscan.ts
var HScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["hscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/hset.ts
var HSetCommand = class extends Command {
  constructor(key, kv) {
    super(["hset", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])]);
  }
};

// pkg/commands/hsetnx.ts
var HSetNXCommand = class extends Command {
  constructor(key, field, value) {
    super(["hsetnx", key, field, value]);
  }
};

// pkg/commands/hstrlen.ts
var HStrLenCommand = class extends Command {
  constructor(key, field) {
    super(["hstrlen", key, field]);
  }
};

// pkg/commands/hvals.ts
var HValsCommand = class extends Command {
  constructor(key) {
    super(["hvals", key]);
  }
};

// pkg/commands/incr.ts
var IncrCommand = class extends Command {
  constructor(key) {
    super(["incr", key]);
  }
};

// pkg/commands/incrby.ts
var IncrByCommand = class extends Command {
  constructor(key, value) {
    super(["incrby", key, value]);
  }
};

// pkg/commands/incrbyfloat.ts
var IncrByFloatCommand = class extends Command {
  constructor(key, value) {
    super(["incrbyfloat", key, value]);
  }
};

// pkg/commands/keys.ts
var KeysCommand = class extends Command {
  constructor(pattern) {
    super(["keys", pattern]);
  }
};

// pkg/commands/lindex.ts
var LIndexCommand = class extends Command {
  constructor(key, index) {
    super(["lindex", key, index]);
  }
};

// pkg/commands/linsert.ts
var LInsertCommand = class extends Command {
  constructor(key, direction, pivot, value) {
    super(["linsert", key, direction, pivot, value]);
  }
};

// pkg/commands/llen.ts
var LLenCommand = class extends Command {
  constructor(key) {
    super(["llen", key]);
  }
};

// pkg/commands/lpop.ts
var LPopCommand = class extends Command {
  constructor(key) {
    super(["lpop", key]);
  }
};

// pkg/commands/lpush.ts
var LPushCommand = class extends Command {
  constructor(key, ...elements) {
    super(["lpush", key, ...elements]);
  }
};

// pkg/commands/lpushx.ts
var LPushXCommand = class extends Command {
  constructor(key, ...elements) {
    super(["lpushx", key, ...elements]);
  }
};

// pkg/commands/lrange.ts
var LRangeCommand = class extends Command {
  constructor(key, start, end) {
    super(["lrange", key, start, end]);
  }
};

// pkg/commands/lrem.ts
var LRemCommand = class extends Command {
  constructor(key, count, value) {
    super(["lrem", key, count, value]);
  }
};

// pkg/commands/lset.ts
var LSetCommand = class extends Command {
  constructor(key, value, index) {
    super(["lset", key, index, value]);
  }
};

// pkg/commands/ltrim.ts
var LTrimCommand = class extends Command {
  constructor(key, start, end) {
    super(["ltrim", key, start, end]);
  }
};

// pkg/commands/mget.ts
var MGetCommand = class extends Command {
  constructor(...keys) {
    super(["mget", ...keys]);
  }
};

// pkg/commands/mset.ts
var MSetCommand = class extends Command {
  constructor(kv) {
    super(["mset", ...Object.entries(kv).flatMap(([key, value]) => [key, value])]);
  }
};

// pkg/commands/msetnx.ts
var MSetNXCommand = class extends Command {
  constructor(kv) {
    super(["msetnx", ...Object.entries(kv).flatMap((_) => _)]);
  }
};

// pkg/commands/persist.ts
var PersistCommand = class extends Command {
  constructor(key) {
    super(["persist", key]);
  }
};

// pkg/commands/pexpire.ts
var PExpireCommand = class extends Command {
  constructor(key, milliseconds) {
    super(["pexpire", key, milliseconds]);
  }
};

// pkg/commands/pexpireat.ts
var PExpireAtCommand = class extends Command {
  constructor(key, unix) {
    super(["pexpireat", key, unix]);
  }
};

// pkg/commands/ping.ts
var PingCommand = class extends Command {
  constructor(message) {
    const command = ["ping"];
    if (typeof message !== "undefined") {
      command.push(message);
    }
    super(command);
  }
};

// pkg/commands/psetex.ts
var PSetEXCommand = class extends Command {
  constructor(key, ttl, value) {
    super(["psetex", key, ttl, value]);
  }
};

// pkg/commands/pttl.ts
var PTtlCommand = class extends Command {
  constructor(key) {
    super(["pttl", key]);
  }
};

// pkg/commands/randomkey.ts
var RandomKeyCommand = class extends Command {
  constructor() {
    super(["randomkey"]);
  }
};

// pkg/commands/rename.ts
var RenameCommand = class extends Command {
  constructor(source, destination) {
    super(["rename", source, destination]);
  }
};

// pkg/commands/renamenx.ts
var RenameNXCommand = class extends Command {
  constructor(source, destination) {
    super(["renamenx", source, destination]);
  }
};

// pkg/commands/rpop.ts
var RPopCommand = class extends Command {
  constructor(key) {
    super(["rpop", key]);
  }
};

// pkg/commands/rpush.ts
var RPushCommand = class extends Command {
  constructor(key, ...elements) {
    super(["rpush", key, ...elements]);
  }
};

// pkg/commands/rpushx.ts
var RPushXCommand = class extends Command {
  constructor(key, ...elements) {
    super(["rpushx", key, ...elements]);
  }
};

// pkg/commands/sadd.ts
var SAddCommand = class extends Command {
  constructor(key, ...members) {
    super(["sadd", key, ...members]);
  }
};

// pkg/commands/scan.ts
var ScanCommand = class extends Command {
  constructor(cursor, opts) {
    const command = ["scan", cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/scard.ts
var SCardCommand = class extends Command {
  constructor(key) {
    super(["scard", key]);
  }
};

// pkg/commands/sdiff.ts
var SDiffCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sdiff", key, ...keys]);
  }
};

// pkg/commands/sdiffstore.ts
var SDiffStoreCommand = class extends Command {
  constructor(destination, ...keys) {
    super(["sdiffstore", destination, ...keys]);
  }
};

// pkg/commands/set.ts
var SetCommand = class extends Command {
  constructor(key, value, opts) {
    const command = ["set", key, value];
    if (opts) {
      if ("ex" in opts && typeof opts.ex === "number") {
        command.push("ex", opts.ex);
      } else if ("px" in opts && typeof opts.px === "number") {
        command.push("px", opts.px);
      }
      if ("nx" in opts && opts.nx) {
        command.push("nx");
      } else if ("xx" in opts && opts.xx) {
        command.push("xx");
      }
    }
    super(command);
  }
};

// pkg/commands/setbit.ts
var SetBitCommand = class extends Command {
  constructor(key, offset, value) {
    super(["setbit", key, offset, value]);
  }
};

// pkg/commands/setex.ts
var SetExCommand = class extends Command {
  constructor(key, ttl, value) {
    super(["setex", key, ttl, value]);
  }
};

// pkg/commands/setnx.ts
var SetNxCommand = class extends Command {
  constructor(key, value) {
    super(["setnx", key, value]);
  }
};

// pkg/commands/setrange.ts
var SetRangeCommand = class extends Command {
  constructor(key, offset, value) {
    super(["setrange", key, offset, value]);
  }
};

// pkg/commands/sinter.ts
var SInterCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sinter", key, ...keys]);
  }
};

// pkg/commands/sinterstore.ts
var SInterStoreCommand = class extends Command {
  constructor(destination, key, ...keys) {
    super(["sinterstore", destination, key, ...keys]);
  }
};

// pkg/commands/sismember.ts
var SIsMemberCommand = class extends Command {
  constructor(key, member) {
    super(["sismember", key, member]);
  }
};

// pkg/commands/smembers.ts
var SMembersCommand = class extends Command {
  constructor(key) {
    super(["smembers", key]);
  }
};

// pkg/commands/smove.ts
var SMoveCommand = class extends Command {
  constructor(source, destination, member) {
    super(["smove", source, destination, member]);
  }
};

// pkg/commands/spop.ts
var SPopCommand = class extends Command {
  constructor(key, count) {
    const command = ["spop", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/srandmember.ts
var SRandMemberCommand = class extends Command {
  constructor(key, count) {
    const command = ["srandmember", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/srem.ts
var SRemCommand = class extends Command {
  constructor(key, ...members) {
    super(["srem", key, ...members]);
  }
};

// pkg/commands/sscan.ts
var SScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["sscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/strlen.ts
var StrLenCommand = class extends Command {
  constructor(key) {
    super(["strlen", key]);
  }
};

// pkg/commands/sunion.ts
var SUnionCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sunion", key, ...keys]);
  }
};

// pkg/commands/sunionstore.ts
var SUnionStoreCommand = class extends Command {
  constructor(destination, key, ...keys) {
    super(["sunionstore", destination, key, ...keys]);
  }
};

// pkg/commands/time.ts
var TimeCommand = class extends Command {
  constructor() {
    super(["time"]);
  }
};

// pkg/commands/touch.ts
var TouchCommand = class extends Command {
  constructor(...keys) {
    super(["touch", ...keys]);
  }
};

// pkg/commands/ttl.ts
var TtlCommand = class extends Command {
  constructor(key) {
    super(["ttl", key]);
  }
};

// pkg/commands/type.ts
var TypeCommand = class extends Command {
  constructor(key) {
    super(["type", key]);
  }
};

// pkg/commands/unlink.ts
var UnlinkCommand = class extends Command {
  constructor(...keys) {
    super(["unlink", ...keys]);
  }
};

// pkg/commands/zadd.ts
var ZAddCommand = class extends Command {
  constructor(key, arg1, ...arg2) {
    const command = ["zadd", key];
    if ("nx" in arg1 && arg1.nx) {
      command.push("nx");
    } else if ("xx" in arg1 && arg1.xx) {
      command.push("xx");
    }
    if ("ch" in arg1 && arg1.ch) {
      command.push("ch");
    }
    if ("incr" in arg1 && arg1.incr) {
      command.push("incr");
    }
    if ("score" in arg1 && "member" in arg1) {
      command.push(arg1.score, arg1.member);
    }
    command.push(...arg2.flatMap(({ score, member }) => [score, member]));
    super(command);
  }
};

// pkg/commands/zcard.ts
var ZCardCommand = class extends Command {
  constructor(key) {
    super(["zcard", key]);
  }
};

// pkg/commands/zcount.ts
var ZCountCommand = class extends Command {
  constructor(key, min, max) {
    super(["zcount", key, min, max]);
  }
};

// pkg/commands/zincrby.ts
var ZIncrByComand = class extends Command {
  constructor(key, increment, member) {
    super(["zincrby", key, increment, member]);
  }
};

// pkg/commands/zinterstore.ts
var ZInterStoreCommand = class extends Command {
  constructor(destination, numKeys, keyOrKeys, opts) {
    const command = ["zinterstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command);
  }
};

// pkg/commands/zlexcount.ts
var ZLexCountCommand = class extends Command {
  constructor(key, min, max) {
    super(["zlexcount", key, min, max]);
  }
};

// pkg/commands/zpopmax.ts
var ZPopMaxCommand = class extends Command {
  constructor(key, count) {
    const command = ["zpopmax", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/zpopmin.ts
var ZPopMinCommand = class extends Command {
  constructor(key, count) {
    const command = ["zpopmin", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/zrange.ts
var ZRangeCommand = class extends Command {
  constructor(key, min, max, opts) {
    const command = ["zrange", key, min, max];
    if (opts == null ? void 0 : opts.withScores) {
      command.push("withscores");
    }
    super(command);
  }
};

// pkg/commands/zrank.ts
var ZRankCommand = class extends Command {
  constructor(key, member) {
    super(["zrank", key, member]);
  }
};

// pkg/commands/zrem.ts
var ZRemCommand = class extends Command {
  constructor(key, ...members) {
    super(["zrem", key, ...members]);
  }
};

// pkg/commands/zremrangebylex.ts
var ZRemRangeByLexCommand = class extends Command {
  constructor(key, min, max) {
    super(["zremrangebylex", key, min, max]);
  }
};

// pkg/commands/zremrangebyrank.ts
var ZRemRangeByRankCommand = class extends Command {
  constructor(key, start, stop) {
    super(["zremrangebyrank", key, start, stop]);
  }
};

// pkg/commands/zremrangebyscore.ts
var ZRemRangeByScoreCommand = class extends Command {
  constructor(key, min, max) {
    super(["zremrangebyscore", key, min, max]);
  }
};

// pkg/commands/zrevrank.ts
var ZRevRankCommand = class extends Command {
  constructor(key, member) {
    super(["zrevrank", key, member]);
  }
};

// pkg/commands/zscan.ts
var ZScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["zscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/zscore.ts
var ZScoreCommand = class extends Command {
  constructor(key, member) {
    super(["zscore", key, member]);
  }
};

// pkg/commands/zunionstore.ts
var ZUnionStoreCommand = class extends Command {
  constructor(destination, numKeys, keyOrKeys, opts) {
    const command = ["zunionstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command);
  }
};

export {
  Command,
  AppendCommand,
  BitCountCommand,
  BitOpCommand,
  BitPosCommand,
  DBSizeCommand,
  DecrCommand,
  DecrByCommand,
  DelCommand,
  EchoCommand,
  ExistsCommand,
  ExpireCommand,
  ExpireAtCommand,
  FlushAllCommand,
  FlushDBCommand,
  GetCommand,
  GetBitCommand,
  GetRangeCommand,
  GetSetCommand,
  HDelCommand,
  HExistsCommand,
  HGetCommand,
  HGetAllCommand,
  HIncrByCommand,
  HIncrByFloatCommand,
  HKeysCommand,
  HLenCommand,
  HMGetCommand,
  HMSetCommand,
  HScanCommand,
  HSetCommand,
  HSetNXCommand,
  HStrLenCommand,
  HValsCommand,
  IncrCommand,
  IncrByCommand,
  IncrByFloatCommand,
  KeysCommand,
  LIndexCommand,
  LInsertCommand,
  LLenCommand,
  LPopCommand,
  LPushCommand,
  LPushXCommand,
  LRangeCommand,
  LRemCommand,
  LSetCommand,
  LTrimCommand,
  MGetCommand,
  MSetCommand,
  MSetNXCommand,
  PersistCommand,
  PExpireCommand,
  PExpireAtCommand,
  PingCommand,
  PSetEXCommand,
  PTtlCommand,
  RandomKeyCommand,
  RenameCommand,
  RenameNXCommand,
  RPopCommand,
  RPushCommand,
  RPushXCommand,
  SAddCommand,
  ScanCommand,
  SCardCommand,
  SDiffCommand,
  SDiffStoreCommand,
  SetCommand,
  SetBitCommand,
  SetExCommand,
  SetNxCommand,
  SetRangeCommand,
  SInterCommand,
  SInterStoreCommand,
  SIsMemberCommand,
  SMembersCommand,
  SMoveCommand,
  SPopCommand,
  SRandMemberCommand,
  SRemCommand,
  SScanCommand,
  StrLenCommand,
  SUnionCommand,
  SUnionStoreCommand,
  TimeCommand,
  TouchCommand,
  TtlCommand,
  TypeCommand,
  UnlinkCommand,
  ZAddCommand,
  ZCardCommand,
  ZCountCommand,
  ZIncrByComand,
  ZInterStoreCommand,
  ZLexCountCommand,
  ZPopMaxCommand,
  ZPopMinCommand,
  ZRangeCommand,
  ZRankCommand,
  ZRemCommand,
  ZRemRangeByLexCommand,
  ZRemRangeByRankCommand,
  ZRemRangeByScoreCommand,
  ZRevRankCommand,
  ZScanCommand,
  ZScoreCommand,
  ZUnionStoreCommand
};
