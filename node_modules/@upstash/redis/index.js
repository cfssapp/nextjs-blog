var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// pkg/index.ts
var pkg_exports = {};
__export(pkg_exports, {
  Redis: () => Redis2,
  UpstashError: () => UpstashError
});

// pkg/error.ts
var UpstashError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UpstashError";
  }
};

// pkg/util.ts
function parseRecursive(obj) {
  const parsed = Array.isArray(obj) ? obj.map((o) => {
    try {
      return parseRecursive(o);
    } catch {
      return o;
    }
  }) : JSON.parse(obj);
  if (typeof parsed === "number" && parsed.toString() != obj) {
    return obj;
  }
  return parsed;
}
function parseResponse(result) {
  try {
    return parseRecursive(result);
  } catch {
    return result;
  }
}

// pkg/commands/command.ts
var Command = class {
  constructor(command, opts) {
    var _a;
    this.command = command.map((c) => typeof c === "string" ? c : JSON.stringify(c));
    this.deserialize = (_a = opts == null ? void 0 : opts.deserialize) != null ? _a : parseResponse;
  }
  async exec(client) {
    const { result, error } = await client.request({
      body: this.command
    });
    if (error) {
      throw new UpstashError(error);
    }
    if (typeof result === "undefined") {
      throw new Error(`Request did not return a result`);
    }
    return this.deserialize(result);
  }
};

// pkg/commands/append.ts
var AppendCommand = class extends Command {
  constructor(key, value) {
    super(["append", key, value]);
  }
};

// pkg/commands/bitcount.ts
var BitCountCommand = class extends Command {
  constructor(key, start, end) {
    const command = ["bitcount", key];
    if (typeof start === "number") {
      command.push(start);
    }
    if (typeof end === "number") {
      command.push(end);
    }
    super(command);
  }
};

// pkg/commands/bitop.ts
var BitOpCommand = class extends Command {
  constructor(op, destinationKey, sourceKey, ...sourceKeys) {
    super(["bitop", op, destinationKey, sourceKey, ...sourceKeys]);
  }
};

// pkg/commands/bitpos.ts
var BitPosCommand = class extends Command {
  constructor(key, start, end) {
    super(["bitpos", key, start, end]);
  }
};

// pkg/commands/dbsize.ts
var DBSizeCommand = class extends Command {
  constructor() {
    super(["dbsize"]);
  }
};

// pkg/commands/decr.ts
var DecrCommand = class extends Command {
  constructor(key) {
    super(["decr", key]);
  }
};

// pkg/commands/decrby.ts
var DecrByCommand = class extends Command {
  constructor(key, decrement) {
    super(["decrby", key, decrement]);
  }
};

// pkg/commands/del.ts
var DelCommand = class extends Command {
  constructor(...keys) {
    super(["del", ...keys]);
  }
};

// pkg/commands/echo.ts
var EchoCommand = class extends Command {
  constructor(message) {
    super(["echo", message]);
  }
};

// pkg/commands/exists.ts
var ExistsCommand = class extends Command {
  constructor(...keys) {
    super(["exists", ...keys]);
  }
};

// pkg/commands/expire.ts
var ExpireCommand = class extends Command {
  constructor(key, seconds) {
    super(["expire", key, seconds]);
  }
};

// pkg/commands/expireat.ts
var ExpireAtCommand = class extends Command {
  constructor(key, unix) {
    super(["expireat", key, unix]);
  }
};

// pkg/commands/flushall.ts
var FlushAllCommand = class extends Command {
  constructor(opts) {
    const command = ["flushall"];
    if (opts == null ? void 0 : opts.async) {
      command.push("async");
    }
    super(command);
  }
};

// pkg/commands/flushdb.ts
var FlushDBCommand = class extends Command {
  constructor(opts) {
    const command = ["flushdb"];
    if (opts == null ? void 0 : opts.async) {
      command.push("async");
    }
    super(command);
  }
};

// pkg/commands/get.ts
var GetCommand = class extends Command {
  constructor(key) {
    super(["get", key]);
  }
};

// pkg/commands/getbit.ts
var GetBitCommand = class extends Command {
  constructor(key, offset) {
    super(["getbit", key, offset]);
  }
};

// pkg/commands/getrange.ts
var GetRangeCommand = class extends Command {
  constructor(key, start, end) {
    super(["getrange", key, start, end]);
  }
};

// pkg/commands/getset.ts
var GetSetCommand = class extends Command {
  constructor(key, value) {
    super(["getset", key, value]);
  }
};

// pkg/commands/hdel.ts
var HDelCommand = class extends Command {
  constructor(key, field) {
    super(["hdel", key, field]);
  }
};

// pkg/commands/hexists.ts
var HExistsCommand = class extends Command {
  constructor(key, field) {
    super(["hexists", key, field]);
  }
};

// pkg/commands/hget.ts
var HGetCommand = class extends Command {
  constructor(key, field) {
    super(["hget", key, field]);
  }
};

// pkg/commands/hgetall.ts
function deserialize(result) {
  if (result.length === 0) {
    return null;
  }
  const obj = {};
  while (result.length >= 2) {
    const key = result.shift();
    const value = result.shift();
    try {
      obj[key] = JSON.parse(value);
    } catch {
      obj[key] = value;
    }
  }
  return obj;
}
var HGetAllCommand = class extends Command {
  constructor(key) {
    super(["hgetall", key], { deserialize: (result) => deserialize(result) });
  }
};

// pkg/commands/hincrby.ts
var HIncrByCommand = class extends Command {
  constructor(key, field, increment) {
    super(["hincrby", key, field, increment]);
  }
};

// pkg/commands/hincrbyfloat.ts
var HIncrByFloatCommand = class extends Command {
  constructor(key, field, increment) {
    super(["hincrbyfloat", key, field, increment]);
  }
};

// pkg/commands/hkeys.ts
var HKeysCommand = class extends Command {
  constructor(key) {
    super(["hkeys", key]);
  }
};

// pkg/commands/hlen.ts
var HLenCommand = class extends Command {
  constructor(key) {
    super(["hlen", key]);
  }
};

// pkg/commands/hmget.ts
function deserialize2(fields, result) {
  if (result.length === 0 || result.every((field) => field === null)) {
    return null;
  }
  const obj = {};
  for (let i = 0; i < fields.length; i++) {
    try {
      obj[fields[i]] = JSON.parse(result[i]);
    } catch {
      obj[fields[i]] = result[i];
    }
  }
  return obj;
}
var HMGetCommand = class extends Command {
  constructor(key, ...fields) {
    super(["hmget", key, ...fields], {
      deserialize: (result) => deserialize2(fields, result)
    });
  }
};

// pkg/commands/hmset.ts
var HMSetCommand = class extends Command {
  constructor(key, kv) {
    super(["hmset", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])]);
  }
};

// pkg/commands/hscan.ts
var HScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["hscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/hset.ts
var HSetCommand = class extends Command {
  constructor(key, kv) {
    super(["hset", key, ...Object.entries(kv).flatMap(([field, value]) => [field, value])]);
  }
};

// pkg/commands/hsetnx.ts
var HSetNXCommand = class extends Command {
  constructor(key, field, value) {
    super(["hsetnx", key, field, value]);
  }
};

// pkg/commands/hstrlen.ts
var HStrLenCommand = class extends Command {
  constructor(key, field) {
    super(["hstrlen", key, field]);
  }
};

// pkg/commands/hvals.ts
var HValsCommand = class extends Command {
  constructor(key) {
    super(["hvals", key]);
  }
};

// pkg/commands/incr.ts
var IncrCommand = class extends Command {
  constructor(key) {
    super(["incr", key]);
  }
};

// pkg/commands/incrby.ts
var IncrByCommand = class extends Command {
  constructor(key, value) {
    super(["incrby", key, value]);
  }
};

// pkg/commands/incrbyfloat.ts
var IncrByFloatCommand = class extends Command {
  constructor(key, value) {
    super(["incrbyfloat", key, value]);
  }
};

// pkg/commands/keys.ts
var KeysCommand = class extends Command {
  constructor(pattern) {
    super(["keys", pattern]);
  }
};

// pkg/commands/lindex.ts
var LIndexCommand = class extends Command {
  constructor(key, index) {
    super(["lindex", key, index]);
  }
};

// pkg/commands/linsert.ts
var LInsertCommand = class extends Command {
  constructor(key, direction, pivot, value) {
    super(["linsert", key, direction, pivot, value]);
  }
};

// pkg/commands/llen.ts
var LLenCommand = class extends Command {
  constructor(key) {
    super(["llen", key]);
  }
};

// pkg/commands/lpop.ts
var LPopCommand = class extends Command {
  constructor(key) {
    super(["lpop", key]);
  }
};

// pkg/commands/lpush.ts
var LPushCommand = class extends Command {
  constructor(key, ...elements) {
    super(["lpush", key, ...elements]);
  }
};

// pkg/commands/lpushx.ts
var LPushXCommand = class extends Command {
  constructor(key, ...elements) {
    super(["lpushx", key, ...elements]);
  }
};

// pkg/commands/lrange.ts
var LRangeCommand = class extends Command {
  constructor(key, start, end) {
    super(["lrange", key, start, end]);
  }
};

// pkg/commands/lrem.ts
var LRemCommand = class extends Command {
  constructor(key, count, value) {
    super(["lrem", key, count, value]);
  }
};

// pkg/commands/lset.ts
var LSetCommand = class extends Command {
  constructor(key, value, index) {
    super(["lset", key, index, value]);
  }
};

// pkg/commands/ltrim.ts
var LTrimCommand = class extends Command {
  constructor(key, start, end) {
    super(["ltrim", key, start, end]);
  }
};

// pkg/commands/mget.ts
var MGetCommand = class extends Command {
  constructor(...keys) {
    super(["mget", ...keys]);
  }
};

// pkg/commands/mset.ts
var MSetCommand = class extends Command {
  constructor(kv) {
    super(["mset", ...Object.entries(kv).flatMap(([key, value]) => [key, value])]);
  }
};

// pkg/commands/msetnx.ts
var MSetNXCommand = class extends Command {
  constructor(kv) {
    super(["msetnx", ...Object.entries(kv).flatMap((_) => _)]);
  }
};

// pkg/commands/persist.ts
var PersistCommand = class extends Command {
  constructor(key) {
    super(["persist", key]);
  }
};

// pkg/commands/pexpire.ts
var PExpireCommand = class extends Command {
  constructor(key, milliseconds) {
    super(["pexpire", key, milliseconds]);
  }
};

// pkg/commands/pexpireat.ts
var PExpireAtCommand = class extends Command {
  constructor(key, unix) {
    super(["pexpireat", key, unix]);
  }
};

// pkg/commands/ping.ts
var PingCommand = class extends Command {
  constructor(message) {
    const command = ["ping"];
    if (typeof message !== "undefined") {
      command.push(message);
    }
    super(command);
  }
};

// pkg/commands/psetex.ts
var PSetEXCommand = class extends Command {
  constructor(key, ttl, value) {
    super(["psetex", key, ttl, value]);
  }
};

// pkg/commands/pttl.ts
var PTtlCommand = class extends Command {
  constructor(key) {
    super(["pttl", key]);
  }
};

// pkg/commands/randomkey.ts
var RandomKeyCommand = class extends Command {
  constructor() {
    super(["randomkey"]);
  }
};

// pkg/commands/rename.ts
var RenameCommand = class extends Command {
  constructor(source, destination) {
    super(["rename", source, destination]);
  }
};

// pkg/commands/renamenx.ts
var RenameNXCommand = class extends Command {
  constructor(source, destination) {
    super(["renamenx", source, destination]);
  }
};

// pkg/commands/rpop.ts
var RPopCommand = class extends Command {
  constructor(key) {
    super(["rpop", key]);
  }
};

// pkg/commands/rpush.ts
var RPushCommand = class extends Command {
  constructor(key, ...elements) {
    super(["rpush", key, ...elements]);
  }
};

// pkg/commands/rpushx.ts
var RPushXCommand = class extends Command {
  constructor(key, ...elements) {
    super(["rpushx", key, ...elements]);
  }
};

// pkg/commands/sadd.ts
var SAddCommand = class extends Command {
  constructor(key, ...members) {
    super(["sadd", key, ...members]);
  }
};

// pkg/commands/scan.ts
var ScanCommand = class extends Command {
  constructor(cursor, opts) {
    const command = ["scan", cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/scard.ts
var SCardCommand = class extends Command {
  constructor(key) {
    super(["scard", key]);
  }
};

// pkg/commands/sdiff.ts
var SDiffCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sdiff", key, ...keys]);
  }
};

// pkg/commands/sdiffstore.ts
var SDiffStoreCommand = class extends Command {
  constructor(destination, ...keys) {
    super(["sdiffstore", destination, ...keys]);
  }
};

// pkg/commands/set.ts
var SetCommand = class extends Command {
  constructor(key, value, opts) {
    const command = ["set", key, value];
    if (opts) {
      if ("ex" in opts && typeof opts.ex === "number") {
        command.push("ex", opts.ex);
      } else if ("px" in opts && typeof opts.px === "number") {
        command.push("px", opts.px);
      }
      if ("nx" in opts && opts.nx) {
        command.push("nx");
      } else if ("xx" in opts && opts.xx) {
        command.push("xx");
      }
    }
    super(command);
  }
};

// pkg/commands/setbit.ts
var SetBitCommand = class extends Command {
  constructor(key, offset, value) {
    super(["setbit", key, offset, value]);
  }
};

// pkg/commands/setex.ts
var SetExCommand = class extends Command {
  constructor(key, ttl, value) {
    super(["setex", key, ttl, value]);
  }
};

// pkg/commands/setnx.ts
var SetNxCommand = class extends Command {
  constructor(key, value) {
    super(["setnx", key, value]);
  }
};

// pkg/commands/setrange.ts
var SetRangeCommand = class extends Command {
  constructor(key, offset, value) {
    super(["setrange", key, offset, value]);
  }
};

// pkg/commands/sinter.ts
var SInterCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sinter", key, ...keys]);
  }
};

// pkg/commands/sinterstore.ts
var SInterStoreCommand = class extends Command {
  constructor(destination, key, ...keys) {
    super(["sinterstore", destination, key, ...keys]);
  }
};

// pkg/commands/sismember.ts
var SIsMemberCommand = class extends Command {
  constructor(key, member) {
    super(["sismember", key, member]);
  }
};

// pkg/commands/smembers.ts
var SMembersCommand = class extends Command {
  constructor(key) {
    super(["smembers", key]);
  }
};

// pkg/commands/smove.ts
var SMoveCommand = class extends Command {
  constructor(source, destination, member) {
    super(["smove", source, destination, member]);
  }
};

// pkg/commands/spop.ts
var SPopCommand = class extends Command {
  constructor(key, count) {
    const command = ["spop", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/srandmember.ts
var SRandMemberCommand = class extends Command {
  constructor(key, count) {
    const command = ["srandmember", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/srem.ts
var SRemCommand = class extends Command {
  constructor(key, ...members) {
    super(["srem", key, ...members]);
  }
};

// pkg/commands/sscan.ts
var SScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["sscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/strlen.ts
var StrLenCommand = class extends Command {
  constructor(key) {
    super(["strlen", key]);
  }
};

// pkg/commands/sunion.ts
var SUnionCommand = class extends Command {
  constructor(key, ...keys) {
    super(["sunion", key, ...keys]);
  }
};

// pkg/commands/sunionstore.ts
var SUnionStoreCommand = class extends Command {
  constructor(destination, key, ...keys) {
    super(["sunionstore", destination, key, ...keys]);
  }
};

// pkg/commands/time.ts
var TimeCommand = class extends Command {
  constructor() {
    super(["time"]);
  }
};

// pkg/commands/touch.ts
var TouchCommand = class extends Command {
  constructor(...keys) {
    super(["touch", ...keys]);
  }
};

// pkg/commands/ttl.ts
var TtlCommand = class extends Command {
  constructor(key) {
    super(["ttl", key]);
  }
};

// pkg/commands/type.ts
var TypeCommand = class extends Command {
  constructor(key) {
    super(["type", key]);
  }
};

// pkg/commands/unlink.ts
var UnlinkCommand = class extends Command {
  constructor(...keys) {
    super(["unlink", ...keys]);
  }
};

// pkg/commands/zadd.ts
var ZAddCommand = class extends Command {
  constructor(key, arg1, ...arg2) {
    const command = ["zadd", key];
    if ("nx" in arg1 && arg1.nx) {
      command.push("nx");
    } else if ("xx" in arg1 && arg1.xx) {
      command.push("xx");
    }
    if ("ch" in arg1 && arg1.ch) {
      command.push("ch");
    }
    if ("incr" in arg1 && arg1.incr) {
      command.push("incr");
    }
    if ("score" in arg1 && "member" in arg1) {
      command.push(arg1.score, arg1.member);
    }
    command.push(...arg2.flatMap(({ score, member }) => [score, member]));
    super(command);
  }
};

// pkg/commands/zcard.ts
var ZCardCommand = class extends Command {
  constructor(key) {
    super(["zcard", key]);
  }
};

// pkg/commands/zcount.ts
var ZCountCommand = class extends Command {
  constructor(key, min, max) {
    super(["zcount", key, min, max]);
  }
};

// pkg/commands/zincrby.ts
var ZIncrByComand = class extends Command {
  constructor(key, increment, member) {
    super(["zincrby", key, increment, member]);
  }
};

// pkg/commands/zinterstore.ts
var ZInterStoreCommand = class extends Command {
  constructor(destination, numKeys, keyOrKeys, opts) {
    const command = ["zinterstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command);
  }
};

// pkg/commands/zlexcount.ts
var ZLexCountCommand = class extends Command {
  constructor(key, min, max) {
    super(["zlexcount", key, min, max]);
  }
};

// pkg/commands/zpopmax.ts
var ZPopMaxCommand = class extends Command {
  constructor(key, count) {
    const command = ["zpopmax", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/zpopmin.ts
var ZPopMinCommand = class extends Command {
  constructor(key, count) {
    const command = ["zpopmin", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command);
  }
};

// pkg/commands/zrange.ts
var ZRangeCommand = class extends Command {
  constructor(key, min, max, opts) {
    const command = ["zrange", key, min, max];
    if (opts == null ? void 0 : opts.withScores) {
      command.push("withscores");
    }
    super(command);
  }
};

// pkg/commands/zrank.ts
var ZRankCommand = class extends Command {
  constructor(key, member) {
    super(["zrank", key, member]);
  }
};

// pkg/commands/zrem.ts
var ZRemCommand = class extends Command {
  constructor(key, ...members) {
    super(["zrem", key, ...members]);
  }
};

// pkg/commands/zremrangebylex.ts
var ZRemRangeByLexCommand = class extends Command {
  constructor(key, min, max) {
    super(["zremrangebylex", key, min, max]);
  }
};

// pkg/commands/zremrangebyrank.ts
var ZRemRangeByRankCommand = class extends Command {
  constructor(key, start, stop) {
    super(["zremrangebyrank", key, start, stop]);
  }
};

// pkg/commands/zremrangebyscore.ts
var ZRemRangeByScoreCommand = class extends Command {
  constructor(key, min, max) {
    super(["zremrangebyscore", key, min, max]);
  }
};

// pkg/commands/zrevrank.ts
var ZRevRankCommand = class extends Command {
  constructor(key, member) {
    super(["zrevrank", key, member]);
  }
};

// pkg/commands/zscan.ts
var ZScanCommand = class extends Command {
  constructor(key, cursor, opts) {
    const command = ["zscan", key, cursor];
    if (opts == null ? void 0 : opts.match) {
      command.push("match", opts.match);
    }
    if (typeof (opts == null ? void 0 : opts.count) === "number") {
      command.push("count", opts.count);
    }
    super(command);
  }
};

// pkg/commands/zscore.ts
var ZScoreCommand = class extends Command {
  constructor(key, member) {
    super(["zscore", key, member]);
  }
};

// pkg/commands/zunionstore.ts
var ZUnionStoreCommand = class extends Command {
  constructor(destination, numKeys, keyOrKeys, opts) {
    const command = ["zunionstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command);
  }
};

// pkg/pipeline.ts
var Pipeline = class {
  constructor(client) {
    this.exec = async () => {
      if (this.commands.length === 0) {
        throw new Error("Pipeline is empty");
      }
      const res = await this.client.request({
        path: ["pipeline"],
        body: Object.values(this.commands).map((c) => c.command)
      });
      return res.map(({ error, result }, i) => {
        if (error) {
          throw new UpstashError(`Command ${i + 1} [ ${this.commands[i].command[0]} ] failed: ${error}`);
        }
        return this.commands[i].deserialize(result);
      });
    };
    this.append = (...args) => this.chain(new AppendCommand(...args));
    this.bitcount = (...args) => this.chain(new BitCountCommand(...args));
    this.bitop = (op, destinationKey, sourceKey, ...sourceKeys) => this.chain(new BitOpCommand(op, destinationKey, sourceKey, ...sourceKeys));
    this.bitpos = (...args) => this.chain(new BitPosCommand(...args));
    this.dbsize = () => this.chain(new DBSizeCommand());
    this.decr = (...args) => this.chain(new DecrCommand(...args));
    this.decrby = (...args) => this.chain(new DecrByCommand(...args));
    this.del = (...args) => this.chain(new DelCommand(...args));
    this.echo = (...args) => this.chain(new EchoCommand(...args));
    this.exists = (...args) => this.chain(new ExistsCommand(...args));
    this.expire = (...args) => this.chain(new ExpireCommand(...args));
    this.expireat = (...args) => this.chain(new ExpireAtCommand(...args));
    this.flushall = (...args) => this.chain(new FlushAllCommand(...args));
    this.flushdb = (...args) => this.chain(new FlushDBCommand(...args));
    this.get = (...args) => this.chain(new GetCommand(...args));
    this.getbit = (...args) => this.chain(new GetBitCommand(...args));
    this.getrange = (...args) => this.chain(new GetRangeCommand(...args));
    this.getset = (key, value) => this.chain(new GetSetCommand(key, value));
    this.hdel = (...args) => this.chain(new HDelCommand(...args));
    this.hexists = (...args) => this.chain(new HExistsCommand(...args));
    this.hget = (...args) => this.chain(new HGetCommand(...args));
    this.hgetall = (...args) => this.chain(new HGetAllCommand(...args));
    this.hincrby = (...args) => this.chain(new HIncrByCommand(...args));
    this.hincrbyfloat = (...args) => this.chain(new HIncrByFloatCommand(...args));
    this.hkeys = (...args) => this.chain(new HKeysCommand(...args));
    this.hlen = (...args) => this.chain(new HLenCommand(...args));
    this.hmget = (...args) => this.chain(new HMGetCommand(...args));
    this.hmset = (key, kv) => this.chain(new HMSetCommand(key, kv));
    this.hscan = (...args) => this.chain(new HScanCommand(...args));
    this.hset = (key, kv) => this.chain(new HSetCommand(key, kv));
    this.hsetnx = (key, field, value) => this.chain(new HSetNXCommand(key, field, value));
    this.hstrlen = (...args) => this.chain(new HStrLenCommand(...args));
    this.hvals = (...args) => this.chain(new HValsCommand(...args));
    this.incr = (...args) => this.chain(new IncrCommand(...args));
    this.incrby = (...args) => this.chain(new IncrByCommand(...args));
    this.incrbyfloat = (...args) => this.chain(new IncrByFloatCommand(...args));
    this.keys = (...args) => this.chain(new KeysCommand(...args));
    this.lindex = (...args) => this.chain(new LIndexCommand(...args));
    this.linsert = (key, direction, pivot, value) => this.chain(new LInsertCommand(key, direction, pivot, value));
    this.llen = (...args) => this.chain(new LLenCommand(...args));
    this.lpop = (...args) => this.chain(new LPopCommand(...args));
    this.lpush = (key, ...elements) => this.chain(new LPushCommand(key, ...elements));
    this.lpushx = (key, ...elements) => this.chain(new LPushXCommand(key, ...elements));
    this.lrange = (...args) => this.chain(new LRangeCommand(...args));
    this.lrem = (key, count, value) => this.chain(new LRemCommand(key, count, value));
    this.lset = (key, value, index) => this.chain(new LSetCommand(key, value, index));
    this.ltrim = (...args) => this.chain(new LTrimCommand(...args));
    this.mget = (...args) => this.chain(new MGetCommand(...args));
    this.mset = (kv) => this.chain(new MSetCommand(kv));
    this.msetnx = (kv) => this.chain(new MSetNXCommand(kv));
    this.persist = (...args) => this.chain(new PersistCommand(...args));
    this.pexpire = (...args) => this.chain(new PExpireCommand(...args));
    this.pexpireat = (...args) => this.chain(new PExpireAtCommand(...args));
    this.ping = (...args) => this.chain(new PingCommand(...args));
    this.psetex = (key, ttl, value) => this.chain(new PSetEXCommand(key, ttl, value));
    this.pttl = (...args) => this.chain(new PTtlCommand(...args));
    this.randomkey = () => this.chain(new RandomKeyCommand());
    this.rename = (...args) => this.chain(new RenameCommand(...args));
    this.renamenx = (...args) => this.chain(new RenameNXCommand(...args));
    this.rpop = (...args) => this.chain(new RPopCommand(...args));
    this.rpush = (key, ...elements) => this.chain(new RPushCommand(key, ...elements));
    this.rpushx = (key, ...elements) => this.chain(new RPushXCommand(key, ...elements));
    this.sadd = (key, ...members) => this.chain(new SAddCommand(key, ...members));
    this.scan = (...args) => this.chain(new ScanCommand(...args));
    this.scard = (...args) => this.chain(new SCardCommand(...args));
    this.sdiff = (...args) => this.chain(new SDiffCommand(...args));
    this.sdiffstore = (...args) => this.chain(new SDiffStoreCommand(...args));
    this.set = (key, value, opts) => this.chain(new SetCommand(key, value, opts));
    this.setbit = (...args) => this.chain(new SetBitCommand(...args));
    this.setex = (key, ttl, value) => this.chain(new SetExCommand(key, ttl, value));
    this.setnx = (key, value) => this.chain(new SetNxCommand(key, value));
    this.setrange = (...args) => this.chain(new SetRangeCommand(...args));
    this.sinter = (...args) => this.chain(new SInterCommand(...args));
    this.sinterstore = (...args) => this.chain(new SInterStoreCommand(...args));
    this.sismember = (key, member) => this.chain(new SIsMemberCommand(key, member));
    this.smembers = (...args) => this.chain(new SMembersCommand(...args));
    this.smove = (source, destination, member) => this.chain(new SMoveCommand(source, destination, member));
    this.spop = (...args) => this.chain(new SPopCommand(...args));
    this.srandmember = (...args) => this.chain(new SRandMemberCommand(...args));
    this.srem = (key, ...members) => this.chain(new SRemCommand(key, ...members));
    this.sscan = (...args) => this.chain(new SScanCommand(...args));
    this.strlen = (...args) => this.chain(new StrLenCommand(...args));
    this.sunion = (...args) => this.chain(new SUnionCommand(...args));
    this.sunionstore = (...args) => this.chain(new SUnionStoreCommand(...args));
    this.time = () => this.chain(new TimeCommand());
    this.touch = (...args) => this.chain(new TouchCommand(...args));
    this.ttl = (...args) => this.chain(new TtlCommand(...args));
    this.type = (...args) => this.chain(new TypeCommand(...args));
    this.unlink = (...args) => this.chain(new UnlinkCommand(...args));
    this.zadd = (...args) => {
      if ("score" in args[1]) {
        return this.chain(new ZAddCommand(args[0], args[1], ...args.slice(2)));
      }
      return this.chain(new ZAddCommand(args[0], args[1], ...args.slice(2)));
    };
    this.zcard = (...args) => this.chain(new ZCardCommand(...args));
    this.zcount = (...args) => this.chain(new ZCountCommand(...args));
    this.zincrby = (key, increment, member) => this.chain(new ZIncrByComand(key, increment, member));
    this.zinterstore = (...args) => this.chain(new ZInterStoreCommand(...args));
    this.zlexcount = (...args) => this.chain(new ZLexCountCommand(...args));
    this.zpopmax = (...args) => this.chain(new ZPopMaxCommand(...args));
    this.zpopmin = (...args) => this.chain(new ZPopMinCommand(...args));
    this.zrange = (...args) => this.chain(new ZRangeCommand(...args));
    this.zrank = (key, member) => this.chain(new ZRankCommand(key, member));
    this.zrem = (key, ...members) => this.chain(new ZRemCommand(key, ...members));
    this.zremrangebylex = (...args) => this.chain(new ZRemRangeByLexCommand(...args));
    this.zremrangebyrank = (...args) => this.chain(new ZRemRangeByRankCommand(...args));
    this.zremrangebyscore = (...args) => this.chain(new ZRemRangeByScoreCommand(...args));
    this.zrevrank = (key, member) => this.chain(new ZRevRankCommand(key, member));
    this.zscan = (...args) => this.chain(new ZScanCommand(...args));
    this.zscore = (key, member) => this.chain(new ZScoreCommand(key, member));
    this.zunionstore = (...args) => this.chain(new ZUnionStoreCommand(...args));
    this.client = client;
    this.commands = [];
  }
  chain(command) {
    this.commands.push(command);
    return this;
  }
};

// pkg/redis.ts
var Redis = class {
  constructor(client) {
    this.pipeline = () => new Pipeline(this.client);
    this.append = (...args) => new AppendCommand(...args).exec(this.client);
    this.bitcount = (...args) => new BitCountCommand(...args).exec(this.client);
    this.bitop = (op, destinationKey, sourceKey, ...sourceKeys) => new BitOpCommand(op, destinationKey, sourceKey, ...sourceKeys).exec(this.client);
    this.bitpos = (...args) => new BitPosCommand(...args).exec(this.client);
    this.dbsize = () => new DBSizeCommand().exec(this.client);
    this.decr = (...args) => new DecrCommand(...args).exec(this.client);
    this.decrby = (...args) => new DecrByCommand(...args).exec(this.client);
    this.del = (...args) => new DelCommand(...args).exec(this.client);
    this.echo = (...args) => new EchoCommand(...args).exec(this.client);
    this.exists = (...args) => new ExistsCommand(...args).exec(this.client);
    this.expire = (...args) => new ExpireCommand(...args).exec(this.client);
    this.expireat = (...args) => new ExpireAtCommand(...args).exec(this.client);
    this.flushall = (...args) => new FlushAllCommand(...args).exec(this.client);
    this.flushdb = (...args) => new FlushDBCommand(...args).exec(this.client);
    this.get = (...args) => new GetCommand(...args).exec(this.client);
    this.getbit = (...args) => new GetBitCommand(...args).exec(this.client);
    this.getrange = (...args) => new GetRangeCommand(...args).exec(this.client);
    this.getset = (key, value) => new GetSetCommand(key, value).exec(this.client);
    this.hdel = (...args) => new HDelCommand(...args).exec(this.client);
    this.hexists = (...args) => new HExistsCommand(...args).exec(this.client);
    this.hget = (...args) => new HGetCommand(...args).exec(this.client);
    this.hgetall = (...args) => new HGetAllCommand(...args).exec(this.client);
    this.hincrby = (...args) => new HIncrByCommand(...args).exec(this.client);
    this.hincrbyfloat = (...args) => new HIncrByFloatCommand(...args).exec(this.client);
    this.hkeys = (...args) => new HKeysCommand(...args).exec(this.client);
    this.hlen = (...args) => new HLenCommand(...args).exec(this.client);
    this.hmget = (...args) => new HMGetCommand(...args).exec(this.client);
    this.hmset = (key, kv) => new HMSetCommand(key, kv).exec(this.client);
    this.hscan = (...args) => new HScanCommand(...args).exec(this.client);
    this.hset = (key, kv) => new HSetCommand(key, kv).exec(this.client);
    this.hsetnx = (key, field, value) => new HSetNXCommand(key, field, value).exec(this.client);
    this.hstrlen = (...args) => new HStrLenCommand(...args).exec(this.client);
    this.hvals = (...args) => new HValsCommand(...args).exec(this.client);
    this.incr = (...args) => new IncrCommand(...args).exec(this.client);
    this.incrby = (...args) => new IncrByCommand(...args).exec(this.client);
    this.incrbyfloat = (...args) => new IncrByFloatCommand(...args).exec(this.client);
    this.keys = (...args) => new KeysCommand(...args).exec(this.client);
    this.lindex = (...args) => new LIndexCommand(...args).exec(this.client);
    this.linsert = (key, direction, pivot, value) => new LInsertCommand(key, direction, pivot, value).exec(this.client);
    this.llen = (...args) => new LLenCommand(...args).exec(this.client);
    this.lpop = (...args) => new LPopCommand(...args).exec(this.client);
    this.lpush = (key, ...elements) => new LPushCommand(key, ...elements).exec(this.client);
    this.lpushx = (key, ...elements) => new LPushXCommand(key, ...elements).exec(this.client);
    this.lrange = (...args) => new LRangeCommand(...args).exec(this.client);
    this.lrem = (key, count, value) => new LRemCommand(key, count, value).exec(this.client);
    this.lset = (key, value, index) => new LSetCommand(key, value, index).exec(this.client);
    this.ltrim = (...args) => new LTrimCommand(...args).exec(this.client);
    this.mget = (...args) => new MGetCommand(...args).exec(this.client);
    this.mset = (kv) => new MSetCommand(kv).exec(this.client);
    this.msetnx = (kv) => new MSetNXCommand(kv).exec(this.client);
    this.persist = (...args) => new PersistCommand(...args).exec(this.client);
    this.pexpire = (...args) => new PExpireCommand(...args).exec(this.client);
    this.pexpireat = (...args) => new PExpireAtCommand(...args).exec(this.client);
    this.ping = (...args) => new PingCommand(...args).exec(this.client);
    this.psetex = (key, ttl, value) => new PSetEXCommand(key, ttl, value).exec(this.client);
    this.pttl = (...args) => new PTtlCommand(...args).exec(this.client);
    this.randomkey = () => new RandomKeyCommand().exec(this.client);
    this.rename = (...args) => new RenameCommand(...args).exec(this.client);
    this.renamenx = (...args) => new RenameNXCommand(...args).exec(this.client);
    this.rpop = (...args) => new RPopCommand(...args).exec(this.client);
    this.rpush = (key, ...elements) => new RPushCommand(key, ...elements).exec(this.client);
    this.rpushx = (key, ...elements) => new RPushXCommand(key, ...elements).exec(this.client);
    this.sadd = (key, ...members) => new SAddCommand(key, ...members).exec(this.client);
    this.scan = (...args) => new ScanCommand(...args).exec(this.client);
    this.scard = (...args) => new SCardCommand(...args).exec(this.client);
    this.sdiff = (...args) => new SDiffCommand(...args).exec(this.client);
    this.sdiffstore = (...args) => new SDiffStoreCommand(...args).exec(this.client);
    this.set = (key, value, opts) => new SetCommand(key, value, opts).exec(this.client);
    this.setbit = (...args) => new SetBitCommand(...args).exec(this.client);
    this.setex = (key, ttl, value) => new SetExCommand(key, ttl, value).exec(this.client);
    this.setnx = (key, value) => new SetNxCommand(key, value).exec(this.client);
    this.setrange = (...args) => new SetRangeCommand(...args).exec(this.client);
    this.sinter = (...args) => new SInterCommand(...args).exec(this.client);
    this.sinterstore = (...args) => new SInterStoreCommand(...args).exec(this.client);
    this.sismember = (key, member) => new SIsMemberCommand(key, member).exec(this.client);
    this.smembers = (...args) => new SMembersCommand(...args).exec(this.client);
    this.smove = (source, destination, member) => new SMoveCommand(source, destination, member).exec(this.client);
    this.spop = (...args) => new SPopCommand(...args).exec(this.client);
    this.srandmember = (...args) => new SRandMemberCommand(...args).exec(this.client);
    this.srem = (key, ...members) => new SRemCommand(key, ...members).exec(this.client);
    this.sscan = (...args) => new SScanCommand(...args).exec(this.client);
    this.strlen = (...args) => new StrLenCommand(...args).exec(this.client);
    this.sunion = (...args) => new SUnionCommand(...args).exec(this.client);
    this.sunionstore = (...args) => new SUnionStoreCommand(...args).exec(this.client);
    this.time = () => new TimeCommand().exec(this.client);
    this.touch = (...args) => new TouchCommand(...args).exec(this.client);
    this.ttl = (...args) => new TtlCommand(...args).exec(this.client);
    this.type = (...args) => new TypeCommand(...args).exec(this.client);
    this.unlink = (...args) => new UnlinkCommand(...args).exec(this.client);
    this.zadd = (...args) => {
      if ("score" in args[1]) {
        return new ZAddCommand(args[0], args[1], ...args.slice(2)).exec(this.client);
      }
      return new ZAddCommand(args[0], args[1], ...args.slice(2)).exec(this.client);
    };
    this.zcard = (...args) => new ZCardCommand(...args).exec(this.client);
    this.zcount = (...args) => new ZCountCommand(...args).exec(this.client);
    this.zincrby = (key, increment, member) => new ZIncrByComand(key, increment, member).exec(this.client);
    this.zinterstore = (...args) => new ZInterStoreCommand(...args).exec(this.client);
    this.zlexcount = (...args) => new ZLexCountCommand(...args).exec(this.client);
    this.zpopmax = (...args) => new ZPopMaxCommand(...args).exec(this.client);
    this.zpopmin = (...args) => new ZPopMinCommand(...args).exec(this.client);
    this.zrange = (...args) => new ZRangeCommand(...args).exec(this.client);
    this.zrank = (key, member) => new ZRankCommand(key, member).exec(this.client);
    this.zrem = (key, ...members) => new ZRemCommand(key, ...members).exec(this.client);
    this.zremrangebylex = (...args) => new ZRemRangeByLexCommand(...args).exec(this.client);
    this.zremrangebyrank = (...args) => new ZRemRangeByRankCommand(...args).exec(this.client);
    this.zremrangebyscore = (...args) => new ZRemRangeByScoreCommand(...args).exec(this.client);
    this.zrevrank = (key, member) => new ZRevRankCommand(key, member).exec(this.client);
    this.zscan = (...args) => new ZScanCommand(...args).exec(this.client);
    this.zscore = (key, member) => new ZScoreCommand(key, member).exec(this.client);
    this.zunionstore = (...args) => new ZUnionStoreCommand(...args).exec(this.client);
    this.client = client;
  }
};

// pkg/http.ts
var HttpClient = class {
  constructor(config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.headers = __spreadValues({
      "Content-Type": "application/json"
    }, config.headers);
    this.options = config.options;
  }
  async request(req) {
    var _a;
    if (!req.path) {
      req.path = [];
    }
    const res = await fetch([this.baseUrl, ...req.path].join("/"), {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(req.body),
      backend: (_a = this.options) == null ? void 0 : _a.backend
    });
    const body = await res.json();
    if (!res.ok) {
      throw new UpstashError(body.error);
    }
    return body;
  }
};

// pkg/nodejs.ts
var import_isomorphic_fetch = require("isomorphic-fetch");
var Redis2 = class extends Redis {
  constructor(config) {
    const client = new HttpClient({
      baseUrl: config.url,
      headers: {
        authorization: `Bearer ${config.token}`
      }
    });
    super(client);
  }
  static fromEnv() {
    if (typeof (process == null ? void 0 : process.env) === "undefined") {
      throw new Error("Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please use `Redis.onCloudflare()` instead");
    }
    const url = process.env["UPSTASH_REDIS_REST_URL"];
    if (!url) {
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");
    }
    const token = process.env["UPSTASH_REDIS_REST_TOKEN"];
    if (!token) {
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`");
    }
    return new Redis2({ url, token });
  }
};
module.exports = __toCommonJS(pkg_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Redis,
  UpstashError
});
