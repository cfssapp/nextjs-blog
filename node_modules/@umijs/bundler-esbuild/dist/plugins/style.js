"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.style = void 0;
// ref: https://github.com/hyrious/esbuild-plugin-style/blob/main/index.ts
const esbuild_1 = __importDefault(require("@umijs/bundler-utils/compiled/esbuild"));
const utils_1 = require("@umijs/utils");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const postcssProcess_1 = require("../utils/postcssProcess");
// https://github.com/evanw/esbuild/issues/20#issuecomment-802269745
function style({ minify = true, charset = 'utf8', inlineStyle, config, } = {}) {
    return {
        name: 'style',
        setup({ onResolve, onLoad }) {
            const cwd = process.cwd();
            const opt = {
                logLevel: 'silent',
                bundle: true,
                write: false,
                charset,
                minify,
                loader: {
                    '.svg': 'dataurl',
                    // file ?
                    '.ttf': 'dataurl',
                },
            };
            onResolve({ filter: /\.css$/, namespace: 'file' }, (args) => {
                const absPath = path_1.default.resolve(cwd, path_1.default.relative(cwd, args.resolveDir), args.path);
                // 通过 resolve 往上找，依赖不一定在 node_modules，可能被提到根目录，并且没有 link
                const resolved = fs_1.default.existsSync(absPath)
                    ? absPath
                    : utils_1.resolve.sync(`${args.path}`, {
                        basedir: args.resolveDir,
                    });
                return { path: resolved, namespace: inlineStyle ? 'style-stub' : '' };
            });
            if (inlineStyle) {
                onResolve({ filter: /\.css$/, namespace: 'style-stub' }, (args) => {
                    return { path: args.path, namespace: 'style-content' };
                });
                onResolve({ filter: /^__style_helper__$/, namespace: 'style-stub' }, (args) => ({
                    path: args.path,
                    namespace: 'style-helper',
                    sideEffects: false,
                }));
                onLoad({ filter: /.*/, namespace: 'style-helper' }, () => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        contents: `
            export function injectStyle(text) {
              if (typeof document !== 'undefined') {
                var style = document.createElement('style')
                var node = document.createTextNode(text)
                style.appendChild(node)
                document.head.appendChild(style)
              }
            }
          `,
                    });
                }));
                onLoad({ filter: /.*/, namespace: 'style-stub' }, (args) => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        contents: `
            import { injectStyle } from "__style_helper__"
            import css from ${JSON.stringify(args.path)}
            injectStyle(css)
          `,
                    });
                }));
            }
            onLoad({
                filter: inlineStyle ? /.*/ : /\.css$/,
                namespace: inlineStyle ? 'style-content' : 'file',
            }, (args) => __awaiter(this, void 0, void 0, function* () {
                const options = Object.assign({ entryPoints: [args.path] }, opt);
                const { errors, warnings, outputFiles } = yield esbuild_1.default.build(options);
                if (errors.length > 0) {
                    return {
                        errors,
                        warnings,
                        contents: outputFiles[0].text,
                        loader: 'text',
                    };
                }
                const dir = path_1.default.dirname(args.path);
                try {
                    const result = yield (0, postcssProcess_1.postcssProcess)(config, outputFiles[0].text, args.path);
                    return {
                        errors,
                        warnings,
                        contents: result.css,
                        loader: inlineStyle ? 'text' : 'css',
                    };
                }
                catch (error) {
                    return {
                        errors: [
                            {
                                text: error.message,
                                location: {
                                    namespace: 'file',
                                    file: error.filename,
                                    line: error.line,
                                    column: error.column,
                                },
                            },
                        ],
                        resolveDir: dir,
                    };
                }
            }));
        },
    };
}
exports.style = style;
