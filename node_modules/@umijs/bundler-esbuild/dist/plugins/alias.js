"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const enhanced_resolve_1 = __importDefault(require("enhanced-resolve"));
const fs_1 = require("fs");
const sortByAffix_1 = require("../utils/sortByAffix");
const resolver = enhanced_resolve_1.default.create({
    mainFields: ['module', 'browser', 'main'],
    extensions: ['.json', '.js', '.jsx', '.ts', '.tsx', '.cjs', '.mjs'],
    // TODO: support exports
    exportsFields: [],
});
function resolve(context, path) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            resolver(context, path, (err, result) => err ? reject(err) : resolve(result));
        });
    });
}
// https://esbuild.github.io/plugins/#resolve-callbacks
exports.default = (options = {}) => {
    return {
        name: 'alias',
        setup({ onResolve }) {
            const keys = (0, sortByAffix_1.sortByAffix)({ arr: Object.keys(options), affix: '$' });
            keys.forEach((key) => {
                let value = options[key];
                let filter;
                if (key.endsWith('$')) {
                    filter = new RegExp(`^${key}`);
                }
                else {
                    filter = new RegExp(`^${key}$`);
                }
                onResolve({ filter: filter }, (args) => __awaiter(this, void 0, void 0, function* () {
                    const path = yield resolve(args.importer, args.path.replace(filter, value));
                    return {
                        path,
                    };
                }));
                if (!key.endsWith('/') &&
                    (0, fs_1.existsSync)(value) &&
                    (0, fs_1.statSync)(value).isDirectory()) {
                    const filter = new RegExp(`^${addSlashAffix(key)}`);
                    onResolve({ filter }, (args) => __awaiter(this, void 0, void 0, function* () {
                        const path = yield resolve(args.importer, args.path.replace(filter, addSlashAffix(value)));
                        return {
                            path,
                        };
                    }));
                }
            });
        },
    };
};
function addSlashAffix(key) {
    if (key.endsWith('/')) {
        return key;
    }
    return `${key}/`;
}
