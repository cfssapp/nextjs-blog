"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParcelCSSMinifyPlugin = void 0;
const utils_1 = require("@umijs/utils");
const buffer_1 = require("buffer");
const path_1 = require("path");
const webpack_sources_1 = require("../../compiled/webpack-sources");
const pkgPath = (0, path_1.join)(__dirname, '../../package.json');
const pkg = require(pkgPath);
const PLUGIN_NAME = 'parcel-css-minify-plugin';
const CSS_FILE_REG = /\.css(?:\?.*)?$/i;
class ParcelCSSMinifyPlugin {
    constructor(opts = {}) {
        this.options = opts;
    }
    apply(compiler) {
        const meta = JSON.stringify({
            name: pkg.name,
            version: pkg.version,
            options: this.options,
        });
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
            compilation.hooks.chunkHash.tap(PLUGIN_NAME, (_, hash) => hash.update(meta));
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                // @ts-ignore
                stage: compilation.constructor.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE,
                additionalAssets: true,
            }, () => __awaiter(this, void 0, void 0, function* () { return yield this.transformAssets(compilation); }));
            compilation.hooks.statsPrinter.tap(PLUGIN_NAME, (statsPrinter) => {
                statsPrinter.hooks.print
                    .for('asset.info.minimized')
                    // @ts-ignore
                    .tap(PLUGIN_NAME, (minimized, { green, formatFlag }) => {
                    // @ts-ignore
                    return minimized ? green(formatFlag('minimized')) : undefined;
                });
            });
        });
    }
    transformAssets(compilation) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options: { devtool }, } = compilation.compiler;
            const sourcemap = this.options.sourceMap === undefined
                ? (devtool && devtool.includes('source-map'))
                : this.options.sourceMap;
            const assets = compilation.getAssets().filter((asset) => {
                return !asset.info.minimized && CSS_FILE_REG.test(asset.name);
            });
            yield Promise.all(assets.map((asset) => __awaiter(this, void 0, void 0, function* () {
                const { source, map } = asset.source.sourceAndMap();
                const sourceAsString = source.toString();
                const code = typeof source === 'string' ? buffer_1.Buffer.from(source) : source;
                const { transform } = (0, utils_1.importLazy)('@parcel/css');
                const result = yield transform(Object.assign({ filename: asset.name, code, minify: true, sourceMap: sourcemap }, this.options));
                const codeString = result.code.toString();
                compilation.updateAsset(asset.name, 
                // @ts-ignore
                sourcemap
                    ? new webpack_sources_1.SourceMapSource(codeString, asset.name, JSON.parse(result.map.toString()), sourceAsString, map, true)
                    : new webpack_sources_1.RawSource(codeString), Object.assign(Object.assign({}, asset.info), { minimized: true }));
            })));
        });
    }
}
exports.ParcelCSSMinifyPlugin = ParcelCSSMinifyPlugin;
