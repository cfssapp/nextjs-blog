"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@swc/core");
const types_1 = require("../types");
function getBaseOpts({ filename }) {
    const isTSFile = filename.endsWith('.ts');
    const isTypeScript = isTSFile || filename.endsWith('.tsx');
    const isDev = process.env.NODE_ENV === types_1.Env.development;
    /**
     * Not use swc auto polyfill , depend on `preset-umi/features/polyfill/polyfill` imported polyfill file
     *
     * @issue https://github.com/swc-project/swc/issues/2607
     *        https://github.com/swc-project/swc/issues/1604
     */
    const swcOpts = {
        module: {
            // @ts-ignore
            type: 'es6',
            ignoreDynamic: true,
        },
        jsc: {
            parser: {
                syntax: isTypeScript ? 'typescript' : 'ecmascript',
                [isTypeScript ? 'tsx' : 'jsx']: !isTSFile,
                dynamicImport: isTypeScript,
            },
            target: 'es2015',
            transform: {
                react: {
                    runtime: 'automatic',
                    pragma: 'React.createElement',
                    pragmaFrag: 'React.Fragment',
                    throwIfNamespace: true,
                    development: isDev,
                    useBuiltins: true,
                },
            },
        },
    };
    return swcOpts;
}
function swcLoader(contents) {
    // 启用异步模式
    const callback = this.async();
    const loaderOpts = this.getOptions();
    const { sync = false, parseMap = false } = loaderOpts, otherOpts = __rest(loaderOpts, ["sync", "parseMap"]);
    const filename = this.resourcePath;
    const swcOpts = Object.assign(Object.assign(Object.assign({}, getBaseOpts({
        filename,
    })), { filename, sourceMaps: this.sourceMap, sourceFileName: filename }), otherOpts);
    try {
        if (sync) {
            const output = (0, core_1.transformSync)(contents, swcOpts);
            callback(null, output.code, parseMap ? JSON.parse(output.map) : output.map);
        }
        else {
            (0, core_1.transform)(contents, swcOpts).then((output) => {
                callback(null, output.code, parseMap ? JSON.parse(output.map) : output.map);
            }, (err) => {
                callback(err);
            });
        }
    }
    catch (e) {
        callback(e);
    }
}
exports.default = swcLoader;
