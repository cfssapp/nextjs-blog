"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.disabledFolders = void 0;
const webpack_1 = require("@umijs/bundler-webpack/compiled/webpack");
const utils_1 = require("@umijs/utils");
const path_1 = __importDefault(require("path"));
exports.disabledFolders = [
    'node_modules',
    '.umi',
    '.umi-production',
    'dist',
];
const detectDeadCode = (compilation, options) => {
    const assets = getWebpackAssets(compilation);
    const compiledFilesDictionary = convertFilesToDict(assets);
    const includedFiles = getPattern(options)
        .map((pattern) => utils_1.glob.sync(pattern))
        .flat();
    const unusedFiles = options.detectUnusedFiles
        ? includedFiles.filter((file) => !compiledFilesDictionary[file])
        : [];
    const unusedExportMap = options.detectUnusedExport
        ? getUnusedExportMap(convertFilesToDict(includedFiles), compilation)
        : {};
    logUnusedFiles(unusedFiles);
    logUnusedExportMap(unusedExportMap);
    const hasUnusedThings = unusedFiles.length || Object.keys(unusedExportMap).length;
    if (hasUnusedThings && options.failOnHint) {
        process.exit(2);
    }
};
const getPattern = (options) => {
    return options.patterns
        .map((pattern) => path_1.default.resolve(options.context || '', pattern))
        .concat(options.exclude.map((pattern) => path_1.default.resolve(options.context || '', `!${pattern}`)))
        .map(convertToUnixPath);
};
const getUnusedExportMap = (includedFileMap, compilation) => {
    const unusedExportMap = {};
    compilation.chunks.forEach((chunk) => {
        compilation.chunkGraph.getChunkModules(chunk).forEach((module) => {
            outputUnusedExportMap(compilation, chunk, module, includedFileMap, unusedExportMap);
        });
    });
    return unusedExportMap;
};
const outputUnusedExportMap = (compilation, chunk, module, includedFileMap, unusedExportMap) => {
    if (!(module instanceof webpack_1.NormalModule) || !module.resource) {
        return;
    }
    const path = convertToUnixPath(module.resource);
    if (!/^((?!(node_modules)).)*$/.test(path))
        return;
    const providedExports = compilation.chunkGraph.moduleGraph.getProvidedExports(module);
    const usedExports = compilation.chunkGraph.moduleGraph.getUsedExports(module, chunk.runtime);
    if (usedExports !== true &&
        providedExports !== true &&
        includedFileMap[path]) {
        if (usedExports === false) {
            if (providedExports === null || providedExports === void 0 ? void 0 : providedExports.length) {
                unusedExportMap[path] = providedExports;
            }
        }
        else if (providedExports instanceof Array) {
            const unusedExports = providedExports.filter((item) => usedExports && !usedExports.has(item));
            if (unusedExports.length) {
                unusedExportMap[path] = unusedExports;
            }
        }
    }
};
const logUnusedExportMap = (unusedExportMap) => {
    if (!Object.keys(unusedExportMap).length) {
        return;
    }
    let numberOfUnusedExport = 0;
    let logStr = '';
    Object.keys(unusedExportMap).forEach((filePath, fileIndex) => {
        const unusedExports = unusedExportMap[filePath];
        logStr += [
            `\n${fileIndex + 1}. `,
            utils_1.chalk.yellow(`${filePath}\n`),
            '    >>>  ',
            utils_1.chalk.yellow(`${unusedExports.join(',  ')}`),
        ].join('');
        numberOfUnusedExport += unusedExports.length;
    });
    console.log(utils_1.chalk.yellow.bold('\nWarning:'), utils_1.chalk.yellow(`There are ${numberOfUnusedExport} unused exports in ${Object.keys(unusedExportMap).length} files:`), logStr, utils_1.chalk.red.bold('\nPlease be careful if you want to remove them (¬º-°)¬.\n'));
};
const getWebpackAssets = (compilation) => {
    const outputPath = compilation.getPath(compilation.compiler.outputPath);
    const assets = [
        ...Array.from(compilation.fileDependencies),
        ...compilation
            .getAssets()
            .map((asset) => path_1.default.join(outputPath, asset.name)),
    ];
    return assets;
};
const convertFilesToDict = (assets) => {
    return assets
        .filter((file) => Boolean(file) &&
        exports.disabledFolders.every((disabledPath) => !file.includes(disabledPath)))
        .reduce((fileDictionary, file) => {
        const unixFile = convertToUnixPath(file);
        fileDictionary[unixFile] = true;
        return fileDictionary;
    }, {});
};
const logUnusedFiles = (unusedFiles) => {
    if (!(unusedFiles === null || unusedFiles === void 0 ? void 0 : unusedFiles.length)) {
        return;
    }
    console.log(utils_1.chalk.yellow.bold('\nWarning:'), utils_1.chalk.yellow(`There are ${unusedFiles.length} unused files:`), ...unusedFiles.map((file, index) => `\n${index + 1}. ${utils_1.chalk.yellow(file)}`), utils_1.chalk.red.bold('\nPlease be careful if you want to remove them (¬º-°)¬.\n'));
};
const convertToUnixPath = (path) => path.replace(/\\+/g, '/');
exports.default = detectDeadCode;
