"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addJavaScriptRules = void 0;
const mfsu_1 = require("@umijs/mfsu");
const utils_1 = require("@umijs/utils");
const webpack_1 = require("../../compiled/webpack");
const constants_1 = require("../constants");
const types_1 = require("../types");
const depMatch_1 = require("../utils/depMatch");
function addJavaScriptRules(opts) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { config, userConfig, cwd, name } = opts;
        const isDev = opts.env === types_1.Env.development;
        const useFastRefresh = isDev && userConfig.fastRefresh !== false && name !== constants_1.MFSU_NAME;
        const depPkgs = Object.assign({}, (0, depMatch_1.es5ImcompatibleVersionsToPkg)());
        const srcRules = [
            config.module
                .rule('src')
                .test(/\.(js|mjs)$/)
                .include.add([
                cwd,
                // import module out of cwd using APP_ROOT
                // issue: https://github.com/umijs/umi/issues/5594
                ...(process.env.APP_ROOT ? [process.cwd()] : []),
            ])
                .end()
                .exclude.add(/node_modules/)
                .end(),
            config.module.rule('jsx-ts-tsx').test(/\.(jsx|ts|tsx)$/),
            config.module
                .rule('extra-src')
                .test(/\.(js|mjs)$/)
                .include.add((path) => {
                try {
                    if (path.includes('client/client'))
                        return true;
                    return (0, depMatch_1.isMatch)({ path, pkgs: depPkgs });
                }
                catch (e) {
                    console.error(utils_1.chalk.red(e));
                    throw e;
                }
            })
                .end(),
        ];
        if (userConfig.mdx) {
            srcRules.push(config.module.rule('markdown').test(/\.mdx?$/));
        }
        const depRules = [
            config.module
                .rule('dep')
                .test(/\.(js|mjs)$/)
                .include.add(/node_modules/)
                .end()
                .exclude.add((path) => {
                try {
                    return (0, depMatch_1.isMatch)({ path, pkgs: depPkgs });
                }
                catch (e) {
                    console.error(utils_1.chalk.red(e));
                    throw e;
                }
            })
                .end(),
        ];
        // const prefix = existsSync(join(cwd, 'src')) ? join(cwd, 'src') : cwd;
        const srcTranspiler = userConfig.srcTranspiler || types_1.Transpiler.babel;
        srcRules.forEach((rule) => {
            if (srcTranspiler === types_1.Transpiler.babel) {
                rule
                    .use('babel-loader')
                    .loader(require.resolve('../../compiled/babel-loader'))
                    .options({
                    // Tell babel to guess the type, instead assuming all files are modules
                    // https://github.com/webpack/webpack/issues/4039#issuecomment-419284940
                    sourceType: 'unambiguous',
                    babelrc: false,
                    cacheDirectory: false,
                    // process.env.BABEL_CACHE !== 'none'
                    //   ? join(cwd, `.umi/.cache/babel-loader`)
                    //   : false,
                    targets: userConfig.targets,
                    presets: [
                        opts.babelPreset || [
                            require.resolve('@umijs/babel-preset-umi'),
                            {
                                presetEnv: {},
                                presetReact: {},
                                presetTypeScript: {},
                                pluginTransformRuntime: {},
                                pluginLockCoreJS: {},
                                pluginDynamicImportNode: false,
                                pluginAutoCSSModules: userConfig.autoCSSModules,
                            },
                        ],
                        ...opts.extraBabelPresets,
                        ...(userConfig.extraBabelPresets || []).filter(Boolean),
                    ],
                    plugins: [
                        useFastRefresh && require.resolve('react-refresh/babel'),
                        ...opts.extraBabelPlugins,
                        ...(userConfig.extraBabelPlugins || []),
                    ].filter(Boolean),
                });
            }
            else if (srcTranspiler === types_1.Transpiler.swc) {
                const AutoCSSModule = require('../swcPlugins/autoCSSModules').default;
                rule
                    .use('swc-loader')
                    .loader(require.resolve('../loader/swc'))
                    .options({
                    plugin: (m) => new AutoCSSModule().visitProgram(m),
                });
            }
            else if (srcTranspiler === types_1.Transpiler.esbuild) {
                rule
                    .use('esbuild-loader')
                    .loader(mfsu_1.esbuildLoader)
                    .options({
                    target: isDev ? 'esnext' : 'es2015',
                    handler: [mfsu_1.autoCssModulesHandler, ...opts.extraEsbuildLoaderHandler],
                });
                // esbuild loader can not auto import `React`
                config.plugin('react-provide-plugin').use(webpack_1.ProvidePlugin, [
                    {
                        React: 'react',
                    },
                ]);
            }
            else {
                throw new Error(`Unsupported srcTranspiler ${srcTranspiler}.`);
            }
        });
        if (userConfig.mdx) {
            config.module
                .rule('mdx')
                .test(/\.mdx?$/)
                .use('mdx-loader')
                .loader((_a = userConfig.mdx) === null || _a === void 0 ? void 0 : _a.loader)
                .options((_b = userConfig.mdx) === null || _b === void 0 ? void 0 : _b.loaderOptions);
        }
        const depTranspiler = userConfig.depTranspiler || types_1.Transpiler.none;
        depRules.forEach((_rule) => {
            if (depTranspiler === types_1.Transpiler.none) {
                // noop
            }
            else {
                throw new Error(`Unsupported depTranspiler ${depTranspiler}.`);
            }
        });
    });
}
exports.addJavaScriptRules = addJavaScriptRules;
