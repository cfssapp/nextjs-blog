"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNeedPolyfill = exports.exactLocalePaths = exports.getLocaleList = exports.getAntdLocale = exports.getMomentLocale = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const plugin_utils_1 = require("umi/plugin-utils");
/**
 * 获取 moment 包的 locale 名称
 * @param lang 语言
 * @param country 国家
 * @param resolveKey 用来resolve的key，moment 或者 dayjs，为了使 dayjs 可以替换 moment
 */
const getMomentLocale = (lang, country, resolveKey) => {
    var _a, _b;
    const momentLocation = require
        .resolve(`${resolveKey}/locale/zh-cn`)
        .replace(/zh\-cn\.js$/, '');
    if ((0, fs_1.existsSync)((0, path_1.join)(momentLocation, `${lang}-${(_a = country === null || country === void 0 ? void 0 : country.toLocaleLowerCase) === null || _a === void 0 ? void 0 : _a.call(country)}.js`))) {
        const momentLocale = `${lang}-${(_b = country === null || country === void 0 ? void 0 : country.toLocaleLowerCase) === null || _b === void 0 ? void 0 : _b.call(country)}`;
        return {
            momentLocale,
        };
    }
    if ((0, fs_1.existsSync)((0, path_1.join)(momentLocation, `${lang}.js`))) {
        return {
            momentLocale: lang,
        };
    }
    return { momentLocale: '' };
};
exports.getMomentLocale = getMomentLocale;
const getAntdLocale = (lang, country) => `${lang}_${(country || lang).toLocaleUpperCase()}`;
exports.getAntdLocale = getAntdLocale;
/**
 * 有些情况下可能项目包含的locale和antd的不匹配
 * 这个方法用于检测
 * @param localePath
 * @returns
 */
const modulesHasLocale = (localePath) => {
    try {
        require.resolve(localePath);
        return true;
    }
    catch (error) {
        return false;
    }
};
const getLocaleList = (opts) => __awaiter(void 0, void 0, void 0, function* () {
    const { localeFolder, separator = '-', absSrcPath = '', absPagesPath = '', addAntdLocales, resolveKey = 'moment', } = opts;
    const localeFileMath = new RegExp(`^([a-z]{2})${separator}?([A-Z]{2})?\.(js|json|ts)$`);
    const localeFiles = plugin_utils_1.glob
        .sync('*.{ts,js,json}', {
        cwd: (0, plugin_utils_1.winPath)((0, path_1.join)(absSrcPath, localeFolder)),
    })
        .map((name) => (0, plugin_utils_1.winPath)((0, path_1.join)(absSrcPath, localeFolder, name)))
        .concat(plugin_utils_1.glob
        .sync(`**/${localeFolder}/*.{ts,js,json}`, {
        cwd: absPagesPath,
    })
        .map((name) => (0, plugin_utils_1.winPath)((0, path_1.join)(absPagesPath, name))))
        .filter((p) => localeFileMath.test((0, path_1.basename)(p)) && (0, fs_1.existsSync)(p))
        .map((fullName) => {
        var _a, _b;
        const fileName = (0, path_1.basename)(fullName);
        const fileInfo = (_b = (_a = localeFileMath
            .exec(fileName)) === null || _a === void 0 ? void 0 : _a.slice(1, 3)) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
        return {
            name: (fileInfo || []).join(separator),
            path: fullName,
        };
    });
    const groups = plugin_utils_1.lodash.groupBy(localeFiles, 'name');
    const promises = Object.keys(groups).map((name) => __awaiter(void 0, void 0, void 0, function* () {
        const [lang, country = ''] = name.split(separator);
        const { momentLocale } = (0, exports.getMomentLocale)(lang, country, resolveKey);
        const antdLocale = plugin_utils_1.lodash
            .uniq(yield addAntdLocales({ lang, country }))
            .filter((localePath) => modulesHasLocale(localePath));
        return {
            lang,
            name,
            // react-intl Function.supportedLocalesOf
            // Uncaught RangeError: Incorrect locale information provided
            locale: name.split(separator).join('-'),
            country,
            antdLocale,
            paths: groups[name].map((item) => (0, plugin_utils_1.winPath)(item.path)),
            momentLocale,
        };
    }));
    return Promise.all(promises);
});
exports.getLocaleList = getLocaleList;
const exactLocalePaths = (data) => {
    return plugin_utils_1.lodash.flatten(data.map((item) => item.paths));
};
exports.exactLocalePaths = exactLocalePaths;
function isNeedPolyfill(targets = {}) {
    // data come from https://caniuse.com/#search=intl
    // you can find all browsers in https://github.com/browserslist/browserslist#browsers
    const polyfillTargets = {
        ie: 10,
        firefox: 28,
        chrome: 23,
        safari: 9.1,
        opera: 12.1,
        ios: 9.3,
        ios_saf: 9.3,
        operamini: Infinity,
        op_mini: Infinity,
        android: 4.3,
        blackberry: Infinity,
        operamobile: 12.1,
        op_mob: 12.1,
        explorermobil: 10,
        ie_mob: 10,
        ucandroid: Infinity,
    };
    return (Object.keys(targets).find((key) => {
        const lowKey = key.toLocaleLowerCase();
        // @ts-ignore
        return polyfillTargets[lowKey] && polyfillTargets[lowKey] >= targets[key];
    }) !== undefined);
}
exports.isNeedPolyfill = isNeedPolyfill;
