"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const esbuild_1 = __importDefault(require("@umijs/bundler-utils/compiled/esbuild"));
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
const types_1 = require("../types");
const RE = {
    plugin: /^(@umijs\/|umi-)plugin-/,
    preset: /^(@umijs\/|umi-)preset-/,
};
class Plugin {
    constructor(opts) {
        this.config = {};
        this.time = { hooks: {} };
        this.enableBy = types_1.EnableBy.register;
        this.type = opts.type;
        this.path = (0, utils_1.winPath)(opts.path);
        this.cwd = opts.cwd;
        (0, assert_1.default)((0, fs_1.existsSync)(this.path), `Invalid ${this.type} ${this.path}, it's not exists.`);
        let pkg = null;
        // path is the package entry
        let isPkgEntry = false;
        const pkgJSONPath = utils_1.pkgUp.pkgUpSync({ cwd: this.path });
        if (pkgJSONPath) {
            pkg = require(pkgJSONPath);
            isPkgEntry =
                (0, utils_1.winPath)((0, path_1.join)((0, path_1.dirname)(pkgJSONPath), pkg.main || 'index.js')) ===
                    (0, utils_1.winPath)(this.path);
        }
        this.id = this.getId({ pkg, isPkgEntry, pkgJSONPath });
        this.key = this.getKey({ pkg, isPkgEntry });
        this.apply = () => {
            utils_1.register.register({
                implementor: esbuild_1.default,
            });
            utils_1.register.clearFiles();
            let ret;
            try {
                ret = require(this.path);
            }
            catch (e) {
                throw new Error(`Register ${this.type} ${this.path} failed, since ${e.message}`);
            }
            for (const file of utils_1.register.getFiles()) {
                delete require.cache[file];
            }
            utils_1.register.restore();
            // use the default member for es modules
            return ret.__esModule ? ret.default : ret;
        };
    }
    merge(opts) {
        if (opts.key)
            this.key = opts.key;
        if (opts.config)
            this.config = opts.config;
        if (opts.enableBy)
            this.enableBy = opts.enableBy;
    }
    getId(opts) {
        let id;
        if (opts.isPkgEntry) {
            id = opts.pkg.name;
        }
        else if ((0, utils_1.winPath)(this.path).startsWith((0, utils_1.winPath)(this.cwd))) {
            id = `./${(0, utils_1.winPath)((0, path_1.relative)(this.cwd, this.path))}`;
        }
        else if (opts.pkgJSONPath) {
            id = (0, utils_1.winPath)((0, path_1.join)(opts.pkg.name, (0, path_1.relative)((0, path_1.dirname)(opts.pkgJSONPath), this.path)));
        }
        else {
            id = (0, utils_1.winPath)(this.path);
        }
        id = id.replace('@umijs/preset-umi/lib/plugins', '@@');
        id = id.replace(/\.js$/, '');
        return id;
    }
    getKey(opts) {
        // e.g.
        // initial-state -> initialState
        // webpack.css-loader -> webpack.cssLoader
        function nameToKey(name) {
            return name
                .split('.')
                .map((part) => utils_1.lodash.camelCase(part))
                .join('.');
        }
        return nameToKey(opts.isPkgEntry
            ? Plugin.stripNoneUmiScope(opts.pkg.name).replace(RE[this.type], '')
            : (0, path_1.basename)(this.path, (0, path_1.extname)(this.path)));
    }
    static isPluginOrPreset(type, name) {
        return RE[type].test(Plugin.stripNoneUmiScope(name));
    }
    static stripNoneUmiScope(name) {
        if (name.charAt(0) === '@' && !name.startsWith('@umijs/')) {
            name = name.split('/')[1];
        }
        return name;
    }
    static getPluginsAndPresets(opts) {
        function get(type) {
            const types = `${type}s`;
            return [
                // opts
                ...(opts[types] || []),
                // env
                ...(process.env[`${opts.prefix}_${types}`.toUpperCase()] || '')
                    .split(',')
                    .filter(Boolean),
                // dependencies
                // ...Object.keys(opts.pkg.devDependencies || {})
                //   .concat(Object.keys(opts.pkg.dependencies || {}))
                //   .filter(Plugin.isPluginOrPreset.bind(null, type)),
                // user config
                ...(opts.userConfig[types] || []),
            ].map((path) => {
                (0, assert_1.default)(typeof path === 'string', `Invalid plugin ${path}, it must be string.`);
                let resolved;
                try {
                    resolved = utils_1.resolve.sync(path, {
                        basedir: opts.cwd,
                        extensions: ['.tsx', '.ts', '.mjs', '.jsx', '.js'],
                    });
                }
                catch (_e) {
                    throw new Error(`Invalid plugin ${path}, can not be resolved.`);
                }
                return new Plugin({
                    path: resolved,
                    type,
                    cwd: opts.cwd,
                });
            });
        }
        return {
            presets: get('preset'),
            plugins: get('plugin'),
        };
    }
}
exports.Plugin = Plugin;
