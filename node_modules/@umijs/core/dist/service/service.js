"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
const tapable_1 = require("../../compiled/tapable");
const config_1 = require("../config/config");
const constants_1 = require("../constants");
const types_1 = require("../types");
const env_1 = require("./env");
const path_2 = require("./path");
const plugin_1 = require("./plugin");
const pluginAPI_1 = require("./pluginAPI");
const utils_2 = require("./utils");
class Service {
    constructor(opts) {
        this.appData = {};
        this.args = { _: [], $0: '' };
        this.commands = {};
        this.generators = {};
        this.config = {};
        this.configSchemas = {};
        this.configDefaults = {};
        this.configOnChanges = {};
        this.hooks = {};
        this.name = '';
        this.paths = {};
        // preset is plugin with different type
        this.plugins = {};
        this.keyToPluginMap = {};
        this.pluginMethods = {};
        this.skipPluginIds = new Set();
        this.stage = types_1.ServiceStage.uninitialized;
        this.userConfig = {};
        this.configManager = null;
        this.pkg = {};
        this.pkgPath = '';
        this.cwd = opts.cwd;
        this.env = opts.env;
        this.opts = opts;
        (0, assert_1.default)((0, fs_1.existsSync)(this.cwd), `Invalid cwd ${this.cwd}, it's not found.`);
    }
    applyPlugins(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const hooks = this.hooks[opts.key] || [];
            let type = opts.type;
            // guess type from key
            if (!type) {
                if (opts.key.startsWith('on')) {
                    type = types_1.ApplyPluginsType.event;
                }
                else if (opts.key.startsWith('modify')) {
                    type = types_1.ApplyPluginsType.modify;
                }
                else if (opts.key.startsWith('add')) {
                    type = types_1.ApplyPluginsType.add;
                }
                else {
                    throw new Error(`Invalid applyPlugins arguments, type must be supplied for key ${opts.key}.`);
                }
            }
            switch (type) {
                case types_1.ApplyPluginsType.add:
                    (0, assert_1.default)(!('initialValue' in opts) || Array.isArray(opts.initialValue), `applyPlugins failed, opts.initialValue must be Array if opts.type is add.`);
                    const tAdd = new tapable_1.AsyncSeriesWaterfallHook(['memo']);
                    for (const hook of hooks) {
                        if (!this.isPluginEnable(hook))
                            continue;
                        tAdd.tapPromise({
                            name: hook.plugin.key,
                            stage: hook.stage,
                            before: hook.before,
                        }, (memo) => __awaiter(this, void 0, void 0, function* () {
                            var _a, _b;
                            const dateStart = new Date();
                            const items = yield hook.fn(opts.args);
                            (_a = hook.plugin.time.hooks)[_b = opts.key] || (_a[_b] = []);
                            hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                            return memo.concat(items);
                        }));
                    }
                    return (yield tAdd.promise(opts.initialValue || []));
                case types_1.ApplyPluginsType.modify:
                    const tModify = new tapable_1.AsyncSeriesWaterfallHook(['memo']);
                    for (const hook of hooks) {
                        if (!this.isPluginEnable(hook))
                            continue;
                        tModify.tapPromise({
                            name: hook.plugin.key,
                            stage: hook.stage,
                            before: hook.before,
                        }, (memo) => __awaiter(this, void 0, void 0, function* () {
                            var _c, _d;
                            const dateStart = new Date();
                            const ret = yield hook.fn(memo, opts.args);
                            (_c = hook.plugin.time.hooks)[_d = opts.key] || (_c[_d] = []);
                            hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                            return ret;
                        }));
                    }
                    return (yield tModify.promise(opts.initialValue));
                case types_1.ApplyPluginsType.event:
                    const tEvent = new tapable_1.AsyncSeriesWaterfallHook(['_']);
                    for (const hook of hooks) {
                        if (!this.isPluginEnable(hook))
                            continue;
                        tEvent.tapPromise({
                            name: hook.plugin.key,
                            stage: hook.stage || 0,
                            before: hook.before,
                        }, () => __awaiter(this, void 0, void 0, function* () {
                            var _f, _g;
                            const dateStart = new Date();
                            yield hook.fn(opts.args);
                            (_f = hook.plugin.time.hooks)[_g = opts.key] || (_f[_g] = []);
                            hook.plugin.time.hooks[opts.key].push(new Date().getTime() - dateStart.getTime());
                        }));
                    }
                    return (yield tEvent.promise(1));
                default:
                    throw new Error(`applyPlugins failed, type is not defined or is not matched, got ${opts.type}.`);
            }
        });
    }
    run(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { name, args = {} } = opts;
            args._ = args._ || [];
            // shift the command itself
            if (args._[0] === name)
                args._.shift();
            this.args = args;
            this.name = name;
            // loadEnv
            this.stage = types_1.ServiceStage.init;
            (0, env_1.loadEnv)({ cwd: this.cwd, envFile: '.env' });
            // get pkg from package.json
            let pkg = {};
            let pkgPath = '';
            try {
                pkg = require((0, path_1.join)(this.cwd, 'package.json'));
                pkgPath = (0, path_1.join)(this.cwd, 'package.json');
            }
            catch (_e) {
                // APP_ROOT
                if (this.cwd !== process.cwd()) {
                    try {
                        pkg = require((0, path_1.join)(process.cwd(), 'package.json'));
                        pkgPath = (0, path_1.join)(process.cwd(), 'package.json');
                    }
                    catch (_e) { }
                }
            }
            this.pkg = pkg;
            this.pkgPath = pkgPath;
            // get user config
            const configManager = new config_1.Config({
                cwd: this.cwd,
                env: this.env,
                defaultConfigFiles: this.opts.defaultConfigFiles,
            });
            this.configManager = configManager;
            this.userConfig = configManager.getUserConfig().config;
            // get paths (move after?)
            // resolve initial presets and plugins
            const { plugins, presets } = plugin_1.Plugin.getPluginsAndPresets({
                cwd: this.cwd,
                pkg,
                plugins: [require.resolve('./generatePlugin')].concat(this.opts.plugins || []),
                presets: [require.resolve('./servicePlugin')].concat(this.opts.presets || []),
                userConfig: this.userConfig,
                prefix: this.opts.frameworkName || constants_1.DEFAULT_FRAMEWORK_NAME,
            });
            // register presets and plugins
            this.stage = types_1.ServiceStage.initPresets;
            const presetPlugins = [];
            while (presets.length) {
                yield this.initPreset({
                    preset: presets.shift(),
                    presets,
                    plugins: presetPlugins,
                });
            }
            plugins.unshift(...presetPlugins);
            this.stage = types_1.ServiceStage.initPlugins;
            while (plugins.length) {
                yield this.initPlugin({ plugin: plugins.shift(), plugins });
            }
            // collect configSchemas and configDefaults
            for (const id of Object.keys(this.plugins)) {
                const { config, key } = this.plugins[id];
                if (config.schema)
                    this.configSchemas[key] = config.schema;
                if (config.default !== undefined) {
                    this.configDefaults[key] = config.default;
                }
                this.configOnChanges[key] = config.onChange || types_1.ConfigChangeType.reload;
            }
            // setup api.config from modifyConfig and modifyDefaultConfig
            const paths = (0, path_2.getPaths)({
                cwd: this.cwd,
                env: this.env,
                prefix: this.opts.frameworkName || constants_1.DEFAULT_FRAMEWORK_NAME,
            });
            this.stage = types_1.ServiceStage.resolveConfig;
            const config = yield this.applyPlugins({
                key: 'modifyConfig',
                // why clone deep?
                // user may change the config in modifyConfig
                // e.g. memo.alias = xxx
                initialValue: utils_1.lodash.cloneDeep(configManager.getConfig({
                    schemas: this.configSchemas,
                }).config),
                args: { paths },
            });
            const defaultConfig = yield this.applyPlugins({
                key: 'modifyDefaultConfig',
                initialValue: this.configDefaults,
            });
            this.config = utils_1.lodash.merge(defaultConfig, config);
            if (this.config.outputPath) {
                paths.absOutputPath = (0, path_1.join)(this.cwd, this.config.outputPath);
            }
            this.paths = yield this.applyPlugins({
                key: 'modifyPaths',
                initialValue: paths,
            });
            // applyPlugin collect app data
            // TODO: some data is mutable
            this.stage = types_1.ServiceStage.collectAppData;
            this.appData = yield this.applyPlugins({
                key: 'modifyAppData',
                initialValue: {
                    // base
                    cwd: this.cwd,
                    pkg,
                    pkgPath,
                    plugins,
                    presets,
                    name,
                    args,
                    // config
                    userConfig: this.userConfig,
                    mainConfigFile: configManager.mainConfigFile,
                    config,
                    defaultConfig: defaultConfig,
                    // TODO
                    // moduleGraph,
                    // routes,
                    // npmClient,
                    // nodeVersion,
                    // gitInfo,
                    // gitBranch,
                    // debugger info,
                    // devPort,
                    // devHost,
                    // env
                },
            });
            // applyPlugin onCheck
            this.stage = types_1.ServiceStage.onCheck;
            yield this.applyPlugins({
                key: 'onCheck',
            });
            // applyPlugin onStart
            this.stage = types_1.ServiceStage.onStart;
            yield this.applyPlugins({
                key: 'onStart',
            });
            // run command
            this.stage = types_1.ServiceStage.runCommand;
            const command = this.commands[name];
            (0, assert_1.default)(command, `Invalid command ${name}, it's not registered.`);
            let ret = command.fn({ args });
            if ((0, utils_2.isPromise)(ret)) {
                ret = yield ret;
            }
            this._baconPlugins();
            return ret;
        });
    }
    _baconPlugins() {
        // TODO: prettier
        if (this.args.baconPlugins) {
            console.log();
            for (const id of Object.keys(this.plugins)) {
                const plugin = this.plugins[id];
                console.log(utils_1.chalk.green('plugin'), plugin.id, plugin.time);
            }
        }
    }
    initPreset(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { presets, plugins } = yield this.initPlugin({
                plugin: opts.preset,
                presets: opts.presets,
                plugins: opts.plugins,
            });
            opts.presets.unshift(...(presets || []));
            opts.plugins.push(...(plugins || []));
        });
    }
    initPlugin(opts) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // register to this.plugins
            (0, assert_1.default)(!this.plugins[opts.plugin.id], `${opts.plugin.type} ${opts.plugin.id} is already registered by ${(_a = this.plugins[opts.plugin.id]) === null || _a === void 0 ? void 0 : _a.path}, ${opts.plugin.type} from ${opts.plugin.path} register failed.`);
            this.plugins[opts.plugin.id] = opts.plugin;
            // apply with PluginAPI
            const pluginAPI = new pluginAPI_1.PluginAPI({
                plugin: opts.plugin,
                service: this,
            });
            pluginAPI.registerPresets = pluginAPI.registerPresets.bind(pluginAPI, opts.presets || []);
            pluginAPI.registerPlugins = pluginAPI.registerPlugins.bind(pluginAPI, opts.plugins);
            const proxyPluginAPI = pluginAPI_1.PluginAPI.proxyPluginAPI({
                service: this,
                pluginAPI,
                serviceProps: [
                    'appData',
                    'applyPlugins',
                    'args',
                    'config',
                    'cwd',
                    'pkg',
                    'pkgPath',
                    'name',
                    'paths',
                    'userConfig',
                    'env',
                    'isPluginEnable',
                ],
                staticProps: {
                    ApplyPluginsType: types_1.ApplyPluginsType,
                    ConfigChangeType: types_1.ConfigChangeType,
                    EnableBy: types_1.EnableBy,
                    ServiceStage: types_1.ServiceStage,
                    service: this,
                },
            });
            let dateStart = new Date();
            let ret = opts.plugin.apply()(proxyPluginAPI);
            if ((0, utils_2.isPromise)(ret)) {
                ret = yield ret;
            }
            opts.plugin.time.register = new Date().getTime() - dateStart.getTime();
            if (opts.plugin.type === 'plugin') {
                (0, assert_1.default)(!ret, `plugin should return nothing`);
            }
            // key should be unique
            (0, assert_1.default)(!this.keyToPluginMap[opts.plugin.key], `key ${opts.plugin.key} is already registered by ${(_b = this.keyToPluginMap[opts.plugin.key]) === null || _b === void 0 ? void 0 : _b.path}, ${opts.plugin.type} from ${opts.plugin.path} register failed.`);
            this.keyToPluginMap[opts.plugin.key] = opts.plugin;
            if (ret === null || ret === void 0 ? void 0 : ret.presets) {
                ret.presets = ret.presets.map((preset) => new plugin_1.Plugin({
                    path: preset,
                    type: types_1.PluginType.preset,
                    cwd: this.cwd,
                }));
            }
            if (ret === null || ret === void 0 ? void 0 : ret.plugins) {
                ret.plugins = ret.plugins.map((plugin) => new plugin_1.Plugin({
                    path: plugin,
                    type: types_1.PluginType.plugin,
                    cwd: this.cwd,
                }));
            }
            return ret || {};
        });
    }
    isPluginEnable(hook) {
        let plugin;
        if (hook.plugin) {
            plugin = hook.plugin;
        }
        else {
            plugin = this.keyToPluginMap[hook];
        }
        const { id, key, enableBy } = plugin;
        if (this.skipPluginIds.has(id))
            return false;
        if (this.userConfig[key] === false)
            return false;
        if (this.config[key] === false)
            return false;
        if (enableBy === types_1.EnableBy.config) {
            // TODO: 提供单独的命令用于启用插件
            // this.userConfig 中如果存在，启用
            // this.config 好了之后如果存在，启用
            // this.config 在 modifyConfig 和 modifyDefaultConfig 之后才会 ready
            // 这意味着 modifyConfig 和 modifyDefaultConfig 只能判断 api.userConfig
            // 举个具体场景:
            //   - p1 enableBy config, p2 modifyDefaultConfig p1 = {}
            //   - p1 里 modifyConfig 和 modifyDefaultConfig 仅 userConfig 里有 p1 有效，其他 p2 开启时即有效
            //   - p2 里因为用了 modifyDefaultConfig，如果 p2 是 enableBy config，需要 userConfig 里配 p2，p2 和 p1 才有效
            return key in this.userConfig || (this.config && key in this.config);
        }
        if (typeof enableBy === 'function')
            return enableBy({
                userConfig: this.userConfig,
                config: this.config,
                env: this.env,
            });
        // EnableBy.register
        return true;
    }
}
exports.Service = Service;
