"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginAPI = void 0;
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const types_1 = require("../types");
const command_1 = require("./command");
const generator_1 = require("./generator");
const hook_1 = require("./hook");
const plugin_1 = require("./plugin");
const utils_2 = require("./utils");
class PluginAPI {
    constructor(opts) {
        this.service = opts.service;
        this.plugin = opts.plugin;
        // logger
        const loggerKeys = [
            'wait',
            'error',
            'warn',
            'ready',
            'info',
            'event',
        ];
        // @ts-ignore
        this.logger = loggerKeys.reduce((memo, key) => {
            // @ts-ignore
            memo[key] = (...message) => {
                // @ts-ignore
                utils_1.logger[key](utils_1.chalk.green(`[plugin: ${this.plugin.id}]`), ...message);
            };
            return memo;
        }, {});
    }
    describe(opts) {
        this.plugin.merge(opts);
    }
    registerCommand(opts) {
        const { alias } = opts;
        delete opts.alias;
        const registerCommand = (commandOpts) => {
            var _a;
            const { name } = commandOpts;
            (0, assert_1.default)(!this.service.commands[name], `api.registerCommand() failed, the command ${name} is exists from ${(_a = this.service.commands[name]) === null || _a === void 0 ? void 0 : _a.plugin.id}.`);
            this.service.commands[name] = new command_1.Command(Object.assign(Object.assign({}, commandOpts), { plugin: this.plugin }));
        };
        registerCommand(opts);
        if (alias) {
            const aliases = (0, utils_2.makeArray)(alias);
            aliases.forEach((alias) => {
                registerCommand(Object.assign(Object.assign({}, opts), { name: alias }));
            });
        }
    }
    registerGenerator(opts) {
        var _a;
        const { key } = opts;
        (0, assert_1.default)(!this.service.generators[key], `api.registerGenerator() failed, the generator ${key} is exists from ${(_a = this.service.generators[key]) === null || _a === void 0 ? void 0 : _a.plugin.id}.`);
        this.service.generators[key] = new generator_1.Generator(Object.assign(Object.assign({}, opts), { plugin: this.plugin }));
    }
    register(opts) {
        var _a, _b;
        (0, assert_1.default)(this.service.stage <= types_1.ServiceStage.initPlugins, 'api.register() should not be called after plugin register stage.');
        (_a = this.service.hooks)[_b = opts.key] || (_a[_b] = []);
        this.service.hooks[opts.key].push(new hook_1.Hook(Object.assign(Object.assign({}, opts), { plugin: this.plugin })));
    }
    registerMethod(opts) {
        (0, assert_1.default)(!this.service.pluginMethods[opts.name], `api.registerMethod() failed, method ${opts.name} is already exist.`);
        this.service.pluginMethods[opts.name] = {
            plugin: this.plugin,
            fn: opts.fn ||
                // 这里不能用 arrow function，this 需指向执行此方法的 PluginAPI
                // 否则 pluginId 会不会，导致不能正确 skip plugin
                function (fn) {
                    // @ts-ignore
                    this.register(Object.assign({ key: opts.name }, (utils_1.lodash.isPlainObject(fn) ? fn : { fn })));
                },
        };
    }
    registerPresets(source, presets) {
        (0, assert_1.default)(this.service.stage === types_1.ServiceStage.initPresets, `api.registerPresets() failed, it should only used in presets.`);
        source.splice(0, 0, ...presets.map((preset) => {
            return new plugin_1.Plugin({
                path: preset,
                cwd: this.service.cwd,
                type: types_1.PluginType.preset,
            });
        }));
    }
    registerPlugins(source, plugins) {
        (0, assert_1.default)(this.service.stage === types_1.ServiceStage.initPresets ||
            this.service.stage === types_1.ServiceStage.initPlugins, `api.registerPlugins() failed, it should only be used in registering stage.`);
        const mappedPlugins = plugins.map((plugin) => {
            if (utils_1.lodash.isPlainObject(plugin)) {
                (0, assert_1.default)(plugin.id && plugin.key, `Invalid plugin object, id and key must supplied.`);
                plugin.type = types_1.PluginType.plugin;
                plugin.enableBy = plugin.enableBy || types_1.EnableBy.register;
                plugin.apply = plugin.apply || (() => () => { });
                plugin.config = plugin.config || {};
                plugin.time = { hooks: {} };
                return plugin;
            }
            else {
                return new plugin_1.Plugin({
                    path: plugin,
                    cwd: this.service.cwd,
                    type: types_1.PluginType.plugin,
                });
            }
        });
        if (this.service.stage === types_1.ServiceStage.initPresets) {
            source.push(...mappedPlugins);
        }
        else {
            source.splice(0, 0, ...mappedPlugins);
        }
    }
    skipPlugins(keys) {
        keys.forEach((key) => {
            (0, assert_1.default)(!(this.plugin.key === key), `plugin ${key} can't skip itself!`);
            (0, assert_1.default)(this.service.keyToPluginMap[key], `key: ${key} is not be registered by any plugin. You can't skip it!`);
            this.service.skipPluginIds.add(this.service.keyToPluginMap[key].id);
        });
    }
    static proxyPluginAPI(opts) {
        return new Proxy(opts.pluginAPI, {
            get: (target, prop) => {
                if (opts.service.pluginMethods[prop]) {
                    return opts.service.pluginMethods[prop].fn;
                }
                if (opts.serviceProps.includes(prop)) {
                    // @ts-ignore
                    const serviceProp = opts.service[prop];
                    return typeof serviceProp === 'function'
                        ? serviceProp.bind(opts.service)
                        : serviceProp;
                }
                if (prop in opts.staticProps) {
                    return opts.staticProps[prop];
                }
                // @ts-ignore
                return target[prop];
            },
        });
    }
}
exports.PluginAPI = PluginAPI;
