"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConventionRoutes = void 0;
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const defineRoutes_1 = require("./defineRoutes");
const utils_2 = require("./utils");
// opts.base: path of pages
function getConventionRoutes(opts) {
    const files = {};
    if (!((0, fs_1.existsSync)(opts.base) && (0, fs_1.statSync)(opts.base).isDirectory())) {
        return {};
    }
    visitFiles({
        dir: opts.base,
        visitor: (file) => {
            const routeId = (0, utils_2.createRouteId)(file);
            if ((0, utils_2.isRouteModuleFile)({ file: (0, utils_1.winPath)(file), exclude: opts.exclude })) {
                files[routeId] = (0, utils_1.winPath)(file);
            }
        },
    });
    const routeIds = Object.keys(files).sort(utils_2.byLongestFirst);
    function defineNestedRoutes(defineRoute, parentId) {
        const childRouteIds = routeIds.filter((id) => (0, utils_2.findParentRouteId)(routeIds, id) === parentId);
        for (let routeId of childRouteIds) {
            let routePath = createRoutePath(parentId ? routeId.slice(parentId.length + 1) : routeId);
            defineRoute({
                path: routePath,
                file: `${opts.prefix || ''}${files[routeId]}`,
                children() {
                    defineNestedRoutes(defineRoute, routeId);
                },
            });
        }
    }
    return (0, defineRoutes_1.defineRoutes)(defineNestedRoutes);
}
exports.getConventionRoutes = getConventionRoutes;
function visitFiles(opts) {
    opts.baseDir = opts.baseDir || opts.dir;
    for (let filename of (0, fs_1.readdirSync)(opts.dir)) {
        let file = (0, path_1.resolve)(opts.dir, filename);
        let stat = (0, fs_1.lstatSync)(file);
        if (stat.isDirectory()) {
            visitFiles(Object.assign(Object.assign({}, opts), { dir: file }));
        }
        else if (stat.isFile() &&
            ['.tsx', '.ts', '.js', '.jsx', '.md', '.mdx'].includes((0, path_1.extname)(file))) {
            opts.visitor((0, path_1.relative)(opts.baseDir, file));
        }
    }
}
function createRoutePath(routeId) {
    let path = routeId
        // routes/$ -> routes/*
        // routes/nested/$.tsx (with a "routes/nested.tsx" layout)
        .replace(/^\$$/, '*')
        // routes/docs.$ -> routes/docs/*
        // routes/docs/$ -> routes/docs/*
        .replace(/(\/|\.)\$$/, '/*')
        // routes/$user -> routes/:user
        .replace(/\$/g, ':')
        // routes/not.nested -> routes/not/nested
        .replace(/\./g, '/');
    path = /\b\/?index$/.test(path) ? path.replace(/\/?index$/, '') : path;
    path = /\b\/?README$/.test(path) ? path.replace(/\/?README$/, '') : path;
    return path;
}
