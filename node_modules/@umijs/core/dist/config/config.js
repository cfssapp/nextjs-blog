"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const esbuild_1 = __importDefault(require("@umijs/bundler-utils/compiled/esbuild"));
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
const joi_1 = __importDefault(require("../../compiled/@hapi/joi"));
const just_diff_1 = require("../../compiled/just-diff");
const constants_1 = require("../constants");
const utils_2 = require("./utils");
class Config {
    constructor(opts) {
        this.files = [];
        this.opts = opts;
        this.mainConfigFile = Config.getMainConfigFile(this.opts);
        this.prevConfig = null;
    }
    getUserConfig() {
        const configFiles = Config.getConfigFiles({
            mainConfigFile: this.mainConfigFile,
            env: this.opts.env,
            specifiedEnv: this.opts.specifiedEnv,
        });
        return Config.getUserConfig({
            configFiles: (0, utils_2.getAbsFiles)({
                files: configFiles,
                cwd: this.opts.cwd,
            }),
        });
    }
    getConfig(opts) {
        const { config, files } = this.getUserConfig();
        Config.validateConfig({ config, schemas: opts.schemas });
        this.files = files;
        return (this.prevConfig = {
            config: config,
            files,
        });
    }
    watch(opts) {
        const watcher = utils_1.chokidar.watch([
            ...this.files,
            ...(this.mainConfigFile
                ? []
                : (0, utils_2.getAbsFiles)({
                    files: this.opts.defaultConfigFiles || constants_1.DEFAULT_CONFIG_FILES,
                    cwd: this.opts.cwd,
                })),
        ], {
            ignoreInitial: true,
            cwd: this.opts.cwd,
        });
        watcher.on('all', utils_1.lodash.debounce((event, path) => {
            const { config: origin } = this.prevConfig;
            const { config: updated, files } = this.getConfig({
                schemas: opts.schemas,
            });
            watcher.add(files);
            const data = Config.diffConfigs({
                origin,
                updated,
                onChangeTypes: opts.onChangeTypes,
            });
            opts
                .onChange({
                data,
                event,
                path,
            })
                .catch((e) => {
                throw new Error(e);
            });
        }, constants_1.WATCH_DEBOUNCE_STEP));
        return () => watcher.close();
    }
    static getMainConfigFile(opts) {
        let mainConfigFile = null;
        for (const configFile of opts.defaultConfigFiles || constants_1.DEFAULT_CONFIG_FILES) {
            const absConfigFile = (0, path_1.join)(opts.cwd, configFile);
            if ((0, fs_1.existsSync)(absConfigFile)) {
                mainConfigFile = absConfigFile;
                break;
            }
        }
        return mainConfigFile;
    }
    static getConfigFiles(opts) {
        const ret = [];
        const { mainConfigFile } = opts;
        const specifiedEnv = opts.specifiedEnv || '';
        if (mainConfigFile) {
            const env = constants_1.SHORT_ENV[opts.env] || opts.env;
            ret.push(...[
                mainConfigFile,
                specifiedEnv &&
                    (0, utils_2.addExt)({ file: mainConfigFile, ext: `.${specifiedEnv}` }),
                (0, utils_2.addExt)({ file: mainConfigFile, ext: `.${env}` }),
                specifiedEnv &&
                    (0, utils_2.addExt)({
                        file: mainConfigFile,
                        ext: `.${env}.${specifiedEnv}`,
                    }),
                (0, utils_2.addExt)({ file: mainConfigFile, ext: constants_1.LOCAL_EXT }),
            ].filter(Boolean));
        }
        return ret;
    }
    static getUserConfig(opts) {
        let config = {};
        let files = [];
        for (const configFile of opts.configFiles) {
            if ((0, fs_1.existsSync)(configFile)) {
                utils_1.register.register({
                    implementor: esbuild_1.default,
                });
                utils_1.register.clearFiles();
                config = utils_1.lodash.merge(config, require(configFile).default);
                for (const file of utils_1.register.getFiles()) {
                    delete require.cache[file];
                }
                // includes the config File
                files.push(...utils_1.register.getFiles());
                utils_1.register.restore();
            }
            else {
                files.push(configFile);
            }
        }
        return {
            config,
            files,
        };
    }
    static validateConfig(opts) {
        const errors = new Map();
        const configKeys = new Set(Object.keys(opts.config));
        for (const key of Object.keys(opts.schemas)) {
            configKeys.delete(key);
            if (!opts.config[key])
                continue;
            const schema = opts.schemas[key](joi_1.default);
            // invalid schema
            (0, assert_1.default)(joi_1.default.isSchema(schema), `schema for config ${key} is not valid.`);
            const { error } = schema.validate(opts.config[key]);
            if (error)
                errors.set(key, error);
        }
        // invalid config values
        (0, assert_1.default)(errors.size === 0, `Invalid config values: ${Array.from(errors.keys()).join(', ')}
${Array.from(errors.keys()).map((key) => {
            return `Invalid value for ${key}:\n${errors.get(key).message}`;
        })}`);
        // invalid config keys
        (0, assert_1.default)(configKeys.size === 0, `Invalid config keys: ${Array.from(configKeys).join(', ')}`);
    }
    static diffConfigs(opts) {
        const patch = (0, just_diff_1.diff)(opts.origin, opts.updated);
        const changes = {};
        const fns = [];
        for (const item of patch) {
            const key = item.path[0];
            const onChange = opts.onChangeTypes[key];
            (0, assert_1.default)(onChange, `Invalid onChange config for key ${key}`);
            if (typeof onChange === 'string') {
                changes[onChange] || (changes[onChange] = []);
                changes[onChange].push(String(key));
            }
            else if (typeof onChange === 'function') {
                fns.push(onChange);
            }
            else {
                throw new Error(`Invalid onChange value for key ${key}`);
            }
        }
        return {
            changes,
            fns,
        };
    }
}
exports.Config = Config;
