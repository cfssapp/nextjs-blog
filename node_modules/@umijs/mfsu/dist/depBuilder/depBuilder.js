"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DepBuilder = void 0;
const bundler_esbuild_1 = require("@umijs/bundler-esbuild");
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../constants");
const depChunkIdPrefixPlugin_1 = require("../webpackPlugins/depChunkIdPrefixPlugin");
const stripSourceMapUrlPlugin_1 = require("../webpackPlugins/stripSourceMapUrlPlugin");
const getESBuildEntry_1 = require("./getESBuildEntry");
class DepBuilder {
    constructor(opts) {
        this.completeFns = [];
        this.isBuilding = false;
        this.opts = opts;
    }
    buildWithWebpack(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.getWebpackConfig({ deps: opts.deps });
            return new Promise((resolve, reject) => {
                const compiler = this.opts.mfsu.opts.implementor(config);
                compiler.run((err, stats) => {
                    opts.onBuildComplete();
                    if (err || (stats === null || stats === void 0 ? void 0 : stats.hasErrors())) {
                        if (err) {
                            reject(err);
                        }
                        if (stats) {
                            const errorMsg = stats.toString('errors-only');
                            // console.error(errorMsg);
                            reject(new Error(errorMsg));
                        }
                    }
                    else {
                        resolve(stats);
                    }
                    compiler.close(() => { });
                });
            });
        });
    }
    // TODO: support watch and rebuild
    buildWithESBuild(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryContent = (0, getESBuildEntry_1.getESBuildEntry)({ deps: opts.deps });
            const ENTRY_FILE = 'esbuild-entry.js';
            const tmpDir = this.opts.mfsu.opts.tmpBase;
            const entryPath = (0, path_1.join)(tmpDir, ENTRY_FILE);
            (0, fs_1.writeFileSync)(entryPath, entryContent, 'utf-8');
            const date = new Date().getTime();
            yield (0, bundler_esbuild_1.build)({
                cwd: this.opts.mfsu.opts.cwd,
                entry: {
                    [`${constants_1.MF_VA_PREFIX}remoteEntry`]: entryPath,
                },
                config: Object.assign(Object.assign({}, this.opts.mfsu.opts.depBuildConfig), { outputPath: tmpDir, alias: this.opts.mfsu.alias, externals: this.opts.mfsu.externals }),
                inlineStyle: true,
            });
            utils_1.logger.event(`[mfsu] compiled with esbuild successfully in ${+new Date() - date} ms`);
            opts.onBuildComplete();
        });
    }
    build(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isBuilding = true;
            yield this.writeMFFiles({ deps: opts.deps });
            const newOpts = Object.assign(Object.assign({}, opts), { onBuildComplete: () => {
                    this.isBuilding = false;
                    this.completeFns.forEach((fn) => fn());
                    this.completeFns = [];
                } });
            if (this.opts.mfsu.opts.buildDepWithESBuild) {
                yield this.buildWithESBuild(newOpts);
            }
            else {
                yield this.buildWithWebpack(newOpts);
            }
        });
    }
    onBuildComplete(fn) {
        if (this.isBuilding) {
            this.completeFns.push(fn);
        }
        else {
            fn();
        }
    }
    writeMFFiles(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const tmpBase = this.opts.mfsu.opts.tmpBase;
            utils_1.fsExtra.mkdirpSync(tmpBase);
            // expose files
            for (const dep of opts.deps) {
                const content = yield dep.buildExposeContent();
                (0, fs_1.writeFileSync)((0, path_1.join)(tmpBase, dep.filePath), content, 'utf-8');
            }
            // index file
            (0, fs_1.writeFileSync)((0, path_1.join)(tmpBase, 'index.js'), '"😛"', 'utf-8');
        });
    }
    getWebpackConfig(opts) {
        var _a, _b;
        const mfName = this.opts.mfsu.opts.mfName;
        const depConfig = utils_1.lodash.cloneDeep(this.opts.mfsu.depConfig);
        // depConfig.stats = 'none';
        depConfig.entry = (0, path_1.join)(this.opts.mfsu.opts.tmpBase, 'index.js');
        depConfig.output.path = this.opts.mfsu.opts.tmpBase;
        // disable devtool
        depConfig.devtool = false;
        // disable library
        // library 会影响 external 的语法，导致报错
        // ref: https://github.com/umijs/plugins/blob/6d3fc2d/packages/plugin-qiankun/src/slave/index.ts#L83
        if ((_a = depConfig.output) === null || _a === void 0 ? void 0 : _a.library)
            delete depConfig.output.library;
        if ((_b = depConfig.output) === null || _b === void 0 ? void 0 : _b.libraryTarget)
            delete depConfig.output.libraryTarget;
        // merge all deps to vendor
        depConfig.optimization || (depConfig.optimization = {});
        depConfig.optimization.splitChunks = {
            chunks: 'all',
            maxInitialRequests: Infinity,
            minSize: 0,
            cacheGroups: {
                vendor: {
                    test: /.+/,
                    name(_module, _chunks, cacheGroupKey) {
                        return `${constants_1.MF_DEP_PREFIX}___${cacheGroupKey}`;
                    },
                },
            },
        };
        depConfig.plugins = depConfig.plugins || [];
        depConfig.plugins.push(new depChunkIdPrefixPlugin_1.DepChunkIdPrefixPlugin());
        depConfig.plugins.push(new stripSourceMapUrlPlugin_1.StripSourceMapUrlPlugin({
            webpack: this.opts.mfsu.opts.implementor,
        }));
        const exposes = opts.deps.reduce((memo, dep) => {
            memo[`./${dep.file}`] = (0, path_1.join)(this.opts.mfsu.opts.tmpBase, dep.filePath);
            return memo;
        }, {});
        depConfig.plugins.push(new this.opts.mfsu.opts.implementor.container.ModuleFederationPlugin({
            library: {
                type: 'global',
                name: mfName,
            },
            name: mfName,
            filename: constants_1.REMOTE_FILE_FULL,
            exposes,
        }));
        return depConfig;
    }
}
exports.DepBuilder = DepBuilder;
