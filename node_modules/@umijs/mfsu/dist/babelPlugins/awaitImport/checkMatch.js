"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPath = exports.checkMatch = void 0;
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const path_1 = require("path");
const getAliasedPath_1 = require("./getAliasedPath");
const isExternals_1 = require("./isExternals");
// const UNMATCH_LIBS = ['umi', 'dumi', '@alipay/bigfish'];
const RE_NODE_MODULES = /node_modules/;
const RE_UMI_LOCAL_DEV = /umi(-next)?\/packages\//;
function isUmiLocalDev(path) {
    return RE_UMI_LOCAL_DEV.test((0, utils_1.winPath)(path));
}
function checkMatch({ value, path, opts, isExportAll, depth, cache, filename, }) {
    var _a, _b;
    let isMatch;
    let replaceValue = '';
    depth = depth || 1;
    (0, assert_1.default)(depth <= 10, `endless loop detected in checkMatch, please check your alias config.`);
    opts = opts || {};
    const remoteName = opts.remoteName || 'mf';
    // FIXME: hard code for vite mode
    value = value.replace(/^@fs\//, '/');
    if (
    // unMatch specified libs
    ((_a = opts.unMatchLibs) === null || _a === void 0 ? void 0 : _a.includes(value)) ||
        // already handled
        value.startsWith(`${remoteName}/`) ||
        // don't match dynamic path
        // e.g. @umijs/deps/compiled/babel/svgr-webpack.js?-svgo,+titleProp,+ref!./umi.svg
        (0, utils_1.winPath)(value).includes('babel/svgr-webpack') ||
        // don't match webpack loader
        // e.g. !!dumi-raw-code-loader!/path/to/VerticalProgress/index.module.less?dumi-raw-code
        value.startsWith('!!') ||
        // don't match externals
        (0, isExternals_1.isExternals)({ value, externals: opts.externals }) ||
        // relative import
        value.startsWith('.')) {
        isMatch = false;
    }
    else if ((0, path_1.isAbsolute)(value)) {
        isMatch = RE_NODE_MODULES.test(value) || isUmiLocalDev(value);
    }
    else {
        const aliasedPath = (0, getAliasedPath_1.getAliasedPath)({
            value,
            alias: opts.alias || {},
        });
        if (aliasedPath) {
            return checkMatch({
                value: aliasedPath,
                path,
                opts,
                isExportAll,
                depth: depth + 1,
                cache,
                filename,
            });
        }
        else {
            isMatch = true;
        }
    }
    if (isMatch && isExportAll) {
        isMatch = !!(opts.exportAllMembers && value in opts.exportAllMembers);
    }
    if (isMatch) {
        replaceValue = `${remoteName}/${(0, utils_1.winPath)(value)}`;
    }
    // @ts-ignore
    const file = (path === null || path === void 0 ? void 0 : path.hub.file.opts.filename) || filename;
    (_b = opts.onTransformDeps) === null || _b === void 0 ? void 0 : _b.call(opts, {
        sourceValue: value,
        replaceValue,
        isMatch,
        file,
    });
    if (cache) {
        let mod;
        if (cache.has(file)) {
            mod = cache.get(file);
        }
        else {
            mod = {
                matched: new Set(),
                unMatched: new Set(),
            };
            cache.set(file, mod);
        }
        mod[isMatch ? 'matched' : 'unMatched'].add({
            sourceValue: value,
            replaceValue,
            file,
        });
    }
    // console.log(
    //   '> check',
    //   // @ts-ignore
    //   path.hub.file.opts.filename,
    //   value,
    //   cache,
    //   'isMatch',
    //   isMatch,
    // );
    return {
        isMatch,
        replaceValue,
    };
}
exports.checkMatch = checkMatch;
// TODO: REMOVE ME
function getPath({ value, opts }) {
    const alias = opts.alias || {};
    for (const key of Object.keys(alias)) {
        if (value.startsWith(key)) {
            return value.replace(key, alias[key]);
        }
    }
    return value;
}
exports.getPath = getPath;
