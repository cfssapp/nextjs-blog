"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MFSU = void 0;
const bundler_utils_1 = require("@umijs/bundler-utils");
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
const mrmime_1 = require("../compiled/mrmime");
// @ts-ignore
const webpack_virtual_modules_1 = __importDefault(require("../compiled/webpack-virtual-modules"));
const autoExport_1 = __importDefault(require("./babelPlugins/autoExport"));
const awaitImport_1 = __importDefault(require("./babelPlugins/awaitImport/awaitImport"));
const getRealPath_1 = require("./babelPlugins/awaitImport/getRealPath");
const constants_1 = require("./constants");
const dep_1 = require("./dep/dep");
const depBuilder_1 = require("./depBuilder/depBuilder");
const depInfo_1 = require("./depInfo");
const autoExport_2 = __importDefault(require("./esbuildHandlers/autoExport"));
const awaitImport_2 = __importDefault(require("./esbuildHandlers/awaitImport"));
const types_1 = require("./types");
const makeArray_1 = require("./utils/makeArray");
const buildDepPlugin_1 = require("./webpackPlugins/buildDepPlugin");
const writeCachePlugin_1 = require("./webpackPlugins/writeCachePlugin");
class MFSU {
    constructor(opts) {
        this.alias = {};
        this.externals = [];
        this.depConfig = null;
        this.opts = opts;
        this.opts.mfName = this.opts.mfName || constants_1.DEFAULT_MF_NAME;
        this.opts.tmpBase =
            this.opts.tmpBase || (0, path_1.join)(process.cwd(), constants_1.DEFAULT_TMP_DIR_NAME);
        this.opts.mode = this.opts.mode || types_1.Mode.development;
        this.opts.getCacheDependency = this.opts.getCacheDependency || (() => ({}));
        this.opts.cwd = this.opts.cwd || process.cwd();
        this.depInfo = new depInfo_1.DepInfo({ mfsu: this });
        this.depBuilder = new depBuilder_1.DepBuilder({ mfsu: this });
        this.depInfo.loadCache();
    }
    // swc don't support top-level await
    // ref: https://github.com/vercel/next.js/issues/31054
    asyncImport(content) {
        return `await import('${(0, utils_1.winPath)(content)}');`;
        // return `(async () => await import('${content}'))();`;
    }
    setWebpackConfig(opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { mfName } = this.opts;
            /**
             * config
             */
            // set alias and externals with reference for babel plugin
            Object.assign(this.alias, ((_a = opts.config.resolve) === null || _a === void 0 ? void 0 : _a.alias) || {});
            this.externals.push(...(0, makeArray_1.makeArray)(opts.config.externals || []));
            // entry
            const entry = {};
            const virtualModules = {};
            // ensure entry object type
            const entryObject = utils_1.lodash.isString(opts.config.entry)
                ? { default: [opts.config.entry] }
                : opts.config.entry;
            (0, assert_1.default)(utils_1.lodash.isPlainObject(entryObject), `webpack config 'entry' value must be a string or an object.`);
            for (const key of Object.keys(entryObject)) {
                const virtualPath = `./mfsu-virtual-entry/${key}.js`;
                const virtualContent = [];
                let index = 1;
                let hasDefaultExport = false;
                const entryFiles = utils_1.lodash.isArray(entryObject[key])
                    ? entryObject[key]
                    : [entryObject[key]];
                for (let entry of entryFiles) {
                    // ensure entry is a file
                    if ((0, fs_1.statSync)(entry).isDirectory()) {
                        const realEntry = (0, utils_1.tryPaths)([
                            (0, path_1.join)(entry, 'index.tsx'),
                            (0, path_1.join)(entry, 'index.ts'),
                        ]);
                        (0, assert_1.default)(realEntry, `entry file not found, please configure the specific entry path. (e.g. 'src/index.tsx')`);
                        entry = realEntry;
                    }
                    const content = (0, fs_1.readFileSync)(entry, 'utf-8');
                    const [_imports, exports] = yield (0, bundler_utils_1.parseModule)({ content, path: entry });
                    if (exports.length) {
                        virtualContent.push(`const k${index} = ${this.asyncImport(entry)}`);
                        for (const exportName of exports) {
                            if (exportName === 'default') {
                                hasDefaultExport = true;
                                virtualContent.push(`export default k${index}.${exportName}`);
                            }
                            else {
                                virtualContent.push(`export const ${exportName} = k${index}.${exportName}`);
                            }
                        }
                    }
                    else {
                        virtualContent.push(this.asyncImport(entry));
                    }
                    index += 1;
                }
                if (!hasDefaultExport) {
                    virtualContent.push(`export default 1;`);
                }
                virtualModules[virtualPath] = virtualContent.join('\n');
                entry[key] = virtualPath;
            }
            opts.config.entry = entry;
            // plugins
            opts.config.plugins = opts.config.plugins || [];
            // support publicPath auto
            let publicPath = opts.config.output.publicPath;
            if (publicPath === 'auto') {
                publicPath = '/';
            }
            opts.config.plugins.push(...[
                new webpack_virtual_modules_1.default(virtualModules),
                new this.opts.implementor.container.ModuleFederationPlugin({
                    name: '__',
                    remotes: {
                        [mfName]: this.opts.runtimePublicPath
                            ? // ref:
                                // https://webpack.js.org/concepts/module-federation/#promise-based-dynamic-remotes
                                `
promise new Promise(resolve => {
  const remoteUrlWithVersion = window.publicPath + '${constants_1.REMOTE_FILE_FULL}';
  const script = document.createElement('script');
  script.src = remoteUrlWithVersion;
  script.onload = () => {
    // the injected script has loaded and is available on window
    // we can now resolve this Promise
    const proxy = {
      get: (request) => window['${mfName}'].get(request),
      init: (arg) => {
        try {
          return window['${mfName}'].init(arg);
        } catch(e) {
          console.log('remote container already initialized');
        }
      }
    }
    resolve(proxy);
  }
  // inject this script with the src set to the versioned remoteEntry.js
  document.head.appendChild(script);
})
                `.trimLeft()
                            : `${mfName}@${publicPath}${constants_1.REMOTE_FILE_FULL}`,
                    },
                }),
                new buildDepPlugin_1.BuildDepPlugin({
                    onCompileDone: () => {
                        this.buildDeps().catch((e) => {
                            utils_1.logger.error(e);
                        });
                    },
                }),
                new writeCachePlugin_1.WriteCachePlugin({
                    onWriteCache: utils_1.lodash.debounce(() => {
                        this.depInfo.writeCache();
                    }, 300),
                }),
            ]);
            // ensure topLevelAwait enabled
            utils_1.lodash.set(opts.config, 'experiments.topLevelAwait', true);
            /**
             * depConfig
             */
            this.depConfig = opts.depConfig;
        });
    }
    buildDeps() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.depInfo.shouldBuild()) {
                utils_1.logger.info('MFSU skip buildDeps');
                return;
            }
            this.depInfo.snapshot();
            const deps = dep_1.Dep.buildDeps({
                deps: this.depInfo.moduleGraph.depSnapshotModules,
                cwd: this.opts.cwd,
                mfsu: this,
            });
            utils_1.logger.info('MFSU buildDeps');
            utils_1.logger.debug(deps.map((dep) => dep.file).join(', '));
            yield this.depBuilder.build({
                deps,
            });
        });
    }
    getMiddlewares() {
        return [
            (req, res, next) => {
                const publicPath = '/';
                const isMF = req.path.startsWith(`${publicPath}${constants_1.MF_VA_PREFIX}`) ||
                    req.path.startsWith(`${publicPath}${constants_1.MF_DEP_PREFIX}`) ||
                    req.path.startsWith(`${publicPath}${constants_1.MF_STATIC_PREFIX}`);
                if (isMF) {
                    this.depBuilder.onBuildComplete(() => {
                        if (!req.path.includes(constants_1.REMOTE_FILE)) {
                            res.setHeader('cache-control', 'max-age=31536000,immutable');
                        }
                        res.setHeader('content-type', (0, mrmime_1.lookup)((0, path_1.extname)(req.path)) || 'text/plain');
                        const relativePath = req.path.replace(new RegExp(`^${publicPath}`), '/');
                        const content = (0, fs_1.readFileSync)((0, path_1.join)(this.opts.tmpBase, relativePath));
                        res.send(content);
                    });
                }
                else {
                    next();
                }
            },
        ];
    }
    getAwaitImportCollectOpts() {
        return {
            onTransformDeps: () => { },
            onCollect: ({ file, data, }) => {
                this.depInfo.moduleGraph.onFileChange({
                    file,
                    // @ts-ignore
                    deps: [
                        ...Array.from(data.matched).map((item) => ({
                            file: item.sourceValue,
                            isDependency: true,
                            version: dep_1.Dep.getDepVersion({
                                dep: item.sourceValue,
                                cwd: this.opts.cwd,
                            }),
                        })),
                        ...Array.from(data.unMatched).map((item) => ({
                            file: (0, getRealPath_1.getRealPath)({
                                file,
                                dep: item.sourceValue,
                            }),
                            isDependency: false,
                        })),
                    ],
                });
            },
            exportAllMembers: this.opts.exportAllMembers,
            unMatchLibs: this.opts.unMatchLibs,
            remoteName: this.opts.mfName,
            alias: this.alias,
            externals: this.externals,
        };
    }
    getBabelPlugins() {
        return [autoExport_1.default, [awaitImport_1.default, this.getAwaitImportCollectOpts()]];
    }
    getEsbuildLoaderHandler() {
        const cache = new Map();
        const checkOpts = this.getAwaitImportCollectOpts();
        return [
            autoExport_2.default,
            (0, awaitImport_2.default)({
                cache,
                opts: checkOpts,
            }),
        ];
    }
}
exports.MFSU = MFSU;
