"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleGraph = void 0;
const utils_1 = require("@umijs/utils");
class ModuleNode {
    constructor(file) {
        this.importers = new Set();
        this.importedModules = new Set();
        this.isDependency = false;
        this.isRoot = false;
        this.version = null;
        this.file = file;
    }
}
class ModuleGraph {
    constructor() {
        this.fileToModules = new Map();
        this.depToModules = new Map();
        this.depSnapshotModules = {};
        this.rootModules = new Set();
    }
    restore(data) {
        let fileMap = new Map();
        const addNode = ({ file, importer }) => {
            // fix circular dependency
            if (fileMap.has(file))
                return;
            fileMap.set(file, true);
            const mod = new ModuleNode(file);
            let isDependency = false;
            let info;
            if (data.fileModules[file]) {
                info = data.fileModules[file];
            }
            else if (data.depModules[file]) {
                info = data.depModules[file];
                isDependency = true;
            }
            if (info.isRoot)
                mod.isRoot = true;
            if (importer) {
                mod.importers.add(importer);
                importer.importedModules.add(mod);
            }
            mod.isDependency = isDependency;
            if (info.version !== undefined) {
                mod.version = info.version;
            }
            if (isDependency) {
                this.depToModules.set(file, mod);
            }
            else {
                for (const importedModule of info.importedModules) {
                    addNode({ file: importedModule, importer: mod });
                }
                this.fileToModules.set(file, mod);
            }
        };
        for (const root of data.roots) {
            addNode({ file: root });
        }
        this.depSnapshotModules = data.depSnapshotModules;
    }
    toJSON() {
        const roots = [];
        const fileModules = {};
        const depModules = {};
        this.depToModules.forEach((value, key) => {
            depModules[key] = {
                version: value.version,
            };
        });
        this.fileToModules.forEach((value, key) => {
            fileModules[key] = {
                importedModules: Array.from(value.importedModules).map((item) => item.file),
            };
            if (value.isRoot) {
                fileModules[key].isRoot = true;
                roots.push(key);
            }
        });
        return {
            roots,
            fileModules,
            depModules,
            depSnapshotModules: this.depSnapshotModules,
        };
    }
    snapshotDeps() {
        this.depSnapshotModules = this.getDepsInfo(this.depToModules);
    }
    getDepsInfo(mods) {
        return Array.from(mods.keys()).reduce((memo, key) => {
            memo[key] = this.getDepInfo(mods.get(key));
            return memo;
        }, {});
    }
    getDepInfo(mod) {
        return {
            file: mod.file,
            version: mod.version,
        };
    }
    hasDepChanged() {
        const depModulesInfo = this.getDepsInfo(this.depToModules);
        return !utils_1.lodash.isEqual(depModulesInfo, this.depSnapshotModules);
    }
    onFileChange(opts) {
        if (this.fileToModules.has(opts.file)) {
            const mod = this.fileToModules.get(opts.file);
            this.updateModule({
                mod,
                deps: opts.deps,
            });
        }
        else {
            const mod = new ModuleNode(opts.file);
            mod.isRoot = true;
            this.fileToModules.set(opts.file, mod);
            this.rootModules.add(mod);
            opts.deps.forEach((dep) => {
                this.addNode({
                    file: dep.file,
                    isDependency: dep.isDependency,
                    version: dep.version || null,
                    importer: mod,
                });
            });
        }
    }
    updateModule(opts) {
        const importedModulesMap = Array.from(opts.mod.importedModules).reduce((memo, mod) => {
            memo[mod.file] = mod;
            return memo;
        }, {});
        const newDeps = [];
        for (const dep of opts.deps) {
            // update
            if (importedModulesMap[dep.file]) {
                if (dep.version !== undefined) {
                    importedModulesMap[dep.file].version = dep.version;
                }
                delete importedModulesMap[dep.file];
            }
            // add
            else {
                newDeps.push(dep);
            }
        }
        Object.keys(importedModulesMap).forEach((key) => {
            this.deleteNode({ mod: importedModulesMap[key], importer: opts.mod });
        });
        newDeps.forEach((dep) => {
            this.addNode(Object.assign(Object.assign({}, dep), { importer: opts.mod }));
        });
    }
    addNode(opts) {
        const modules = opts.isDependency ? this.depToModules : this.fileToModules;
        let mod;
        if (modules.has(opts.file)) {
            mod = modules.get(opts.file);
            if (opts.version !== undefined)
                mod.version = opts.version;
        }
        else {
            mod = new ModuleNode(opts.file);
            mod.isDependency = opts.isDependency;
            if (opts.version !== undefined)
                mod.version = opts.version;
            modules.set(opts.file, mod);
        }
        if (!mod.importers.has(opts.importer)) {
            mod.importers.add(opts.importer);
        }
        if (!opts.importer.importedModules.has(mod)) {
            opts.importer.importedModules.add(mod);
        }
    }
    deleteNode(opts) {
        const modules = opts.mod.isDependency
            ? this.depToModules
            : this.fileToModules;
        const { mod, importer } = opts;
        mod.importers.delete(opts.importer);
        importer.importedModules.delete(mod);
        if (!mod.importers.size) {
            modules.delete(opts.mod.file);
            mod.importedModules.forEach((importedModule) => {
                this.deleteNode({
                    mod: importedModule,
                    importer: mod,
                });
            });
        }
    }
}
exports.ModuleGraph = ModuleGraph;
