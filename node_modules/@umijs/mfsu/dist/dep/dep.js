"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dep = void 0;
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const enhanced_resolve_1 = __importDefault(require("enhanced-resolve"));
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../constants");
const trimFileContent_1 = require("../utils/trimFileContent");
const getExposeFromContent_1 = require("./getExposeFromContent");
const resolver = enhanced_resolve_1.default.create({
    mainFields: ['module', 'browser', 'main'],
    extensions: ['.js', '.json', '.mjs'],
    // TODO: support exports
    // tried to add exports, but it don't work with swr
    exportsFields: [],
});
function resolve(context, path) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            resolver(context, path, (err, result) => err ? reject(err) : resolve(result));
        });
    });
}
class Dep {
    constructor(opts) {
        this.file = (0, utils_1.winPath)(opts.file);
        this.version = opts.version;
        this.cwd = opts.cwd;
        this.shortFile = this.file;
        this.normalizedFile = this.shortFile.replace(/\//g, '_').replace(/:/g, '_');
        this.filePath = `${constants_1.MF_VA_PREFIX}${this.normalizedFile}.js`;
        this.mfsu = opts.mfsu;
    }
    buildExposeContent() {
        return __awaiter(this, void 0, void 0, function* () {
            // node natives
            // @ts-ignore
            const isNodeNatives = !!process.binding('natives')[this.file];
            if (isNodeNatives) {
                return (0, trimFileContent_1.trimFileContent)(this.mfsu.opts.excludeNodeNatives
                    ? `
const _ = require('${this.file}');
module.exports = _;
      `
                    : `
import _ from '${this.file}';
export default _;
export * from '${this.file}';
      `);
            }
            // none node natives
            const realFile = yield this.getRealFile();
            (0, assert_1.default)(realFile, `filePath not found of ${this.file}`);
            const content = (0, fs_1.readFileSync)(realFile, 'utf-8');
            return yield (0, getExposeFromContent_1.getExposeFromContent)({
                content,
                filePath: realFile,
                dep: this,
            });
        });
    }
    getRealFile() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // don't need to handle alias here
                // it's already handled by babel plugin
                return yield resolve(this.cwd, this.file);
            }
            catch (e) {
                return null;
            }
        });
    }
    static buildDeps(opts) {
        return Object.keys(opts.deps).map((file) => {
            return new Dep(Object.assign(Object.assign({}, opts.deps[file]), { cwd: opts.cwd, mfsu: opts.mfsu }));
        });
    }
    static getDepVersion(opts) {
        // @ts-ignore
        if (!!process.binding('natives')[opts.dep]) {
            return '*';
        }
        const dep = (0, path_1.isAbsolute)(opts.dep)
            ? opts.dep
            : (0, path_1.join)(opts.cwd, 'node_modules', opts.dep);
        const pkg = utils_1.pkgUp.pkgUpSync({
            cwd: dep,
        });
        (0, assert_1.default)(pkg, `package.json not found for ${opts.dep}`);
        return require(pkg).version;
    }
}
exports.Dep = Dep;
