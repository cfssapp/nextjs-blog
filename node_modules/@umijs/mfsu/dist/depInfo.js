"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DepInfo = void 0;
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const moduleGraph_1 = require("./moduleGraph");
class DepInfo {
    constructor(opts) {
        this.moduleGraph = new moduleGraph_1.ModuleGraph();
        this.cacheDependency = {};
        this.opts = opts;
        this.cacheFilePath = (0, path_1.join)(this.opts.mfsu.opts.tmpBase, 'MFSU_CACHE.json');
    }
    shouldBuild() {
        if (!utils_1.lodash.isEqual(this.cacheDependency, this.opts.mfsu.opts.getCacheDependency())) {
            return true;
        }
        if (this.moduleGraph.hasDepChanged()) {
            return true;
        }
        return false;
    }
    snapshot() {
        this.cacheDependency = this.opts.mfsu.opts.getCacheDependency();
        this.moduleGraph.snapshotDeps();
    }
    loadCache() {
        if ((0, fs_1.existsSync)(this.cacheFilePath)) {
            utils_1.logger.info('MFSU restore cache');
            const { cacheDependency, moduleGraph } = JSON.parse((0, fs_1.readFileSync)(this.cacheFilePath, 'utf-8'));
            this.cacheDependency = cacheDependency;
            this.moduleGraph.restore(moduleGraph);
        }
    }
    writeCache() {
        utils_1.fsExtra.mkdirpSync((0, path_1.dirname)(this.cacheFilePath));
        utils_1.logger.info('MFSU write cache');
        (0, fs_1.writeFileSync)(this.cacheFilePath, JSON.stringify({
            cacheDependency: this.cacheDependency,
            moduleGraph: this.moduleGraph.toJSON(),
        }, null, 2), 'utf-8');
    }
}
exports.DepInfo = DepInfo;
