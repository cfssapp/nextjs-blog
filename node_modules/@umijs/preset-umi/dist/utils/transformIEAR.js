"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IEAR_REG_EXP = void 0;
const bundler_utils_1 = require("@umijs/bundler-utils");
const utils_1 = require("@umijs/utils");
const path_1 = require("path");
/**
 * import/export/await-import/require match regular expression
 *
 * WHY: REGEXP
 * ref: https://github.com/umijs/umi-next/pull/230
 *
 * TODO: more choices
 * 1. fork es-module-lexer, support jsx
 * 2. use sourcemap of esbuild
 */
exports.IEAR_REG_EXP = new RegExp([
    // match content before quote ($1)
    '(',
    [
        // import/export statements
        [
            '(?:',
            // match head
            '(?:^|\\r|\\n|;)\\s*',
            // match identifier
            '(?:import|export)\\s+',
            [
                '(?:',
                '(?:',
                // match body
                [
                    // match default & member import
                    [
                        // match default import
                        [
                            '(?:',
                            // match type import
                            '(?:type\\s*)?',
                            // match variable name
                            '[a-zA-Z_$][\\w_$]*\\s*,?\\s+',
                            // optional
                            ')?',
                        ].join(''),
                        // match member import/export (optional)
                        '(?:{[^}]+}\\s+)?',
                    ].join(''),
                    // match contents import/export
                    '(?:type\\s*)?\\*\\s+(?:as\\s+[a-zA-Z][\\w_$]*\\s+)?',
                ].join('|'),
                ')',
                // match from
                'from\\s+',
                // match direct file import
                '|\\s*',
                ')',
            ].join(''),
            ')',
        ].join(''),
        // import/require call
        [
            // match head (must be single function name)
            '(?:^|[^a-zA-Z\\w_$\\.])',
            // match call
            '(?:import|require)\\(\\s*',
        ].join(''),
    ].join('|'),
    ')',
    '(?:',
    // match quotes ($2)
    `('|")`,
    // match absolute file path ($3)
    `(\\/.*[^\\\\])\\2`,
    ')',
].join(''), 
// match full-content
'g');
/**
 * transform absolute import/export/await-import/require path
 * @note  use to vite can deps:
 *        transform to relative path for .umi dir imports
 *        prefix `@fs` for node_modules imports
 */
function transformIEAR({ content, path }, api) {
    return content.replace(exports.IEAR_REG_EXP, (_, prefix, quote, absPath) => {
        if (absPath.startsWith(api.paths.absTmpPath)) {
            // transform .umi absolute imports
            absPath = (0, utils_1.winPath)((0, path_1.relative)((0, path_1.dirname)(path), absPath)).replace(
            // prepend ./ for same or sub level imports
            /^(?!\.\.\/)/, './');
        }
        else if ((0, bundler_utils_1.isDepPath)(absPath)) {
            // transform node_modules absolute imports
            // why @fs
            // 由于我们临时文件下大量绝对路径的引用，而绝对路径的引用不会被 Vite 预编译
            absPath = `@fs${absPath}`;
        }
        return `${prefix}${quote}${absPath}${quote}`;
    });
}
exports.default = transformIEAR;
