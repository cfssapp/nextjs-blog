"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMockMiddleware = void 0;
const path_to_regexp_1 = __importDefault(require("path-to-regexp"));
const body_parser_1 = __importDefault(require("../../../compiled/body-parser"));
const multer_1 = __importDefault(require("../../../compiled/multer"));
function createMockMiddleware(opts) {
    return (req, res, next) => {
        const method = req.method.toUpperCase();
        for (const key of Object.keys(opts.context.mockData)) {
            const mock = opts.context.mockData[key];
            if (mock.method !== method)
                continue;
            const { keys, re } = getPathReAndKeys(mock.path);
            const m = re.exec(req.path);
            if (m) {
                if (typeof mock.handler === 'function') {
                    // add params
                    const params = {};
                    for (let i = 1; i < m.length; i += 1) {
                        const key = keys[i - 1];
                        const prop = key.name;
                        const val = decodeParam(m[i]);
                        if (val !== undefined) {
                            params[prop] = val;
                        }
                    }
                    req.params = params;
                    // handler
                    if (method === 'GET') {
                        mock.handler(req, res, next);
                    }
                    else {
                        const jsonOpts = { limit: '5mb', strict: false };
                        const urlEncodedOpts = { limit: '5mb', extended: true };
                        // body parser + multer
                        body_parser_1.default.json(jsonOpts)(req, res, () => {
                            body_parser_1.default.urlencoded(urlEncodedOpts)(req, res, () => {
                                (0, multer_1.default)().any()(req, res, () => {
                                    mock.handler(req, res, next);
                                });
                            });
                        });
                    }
                }
                else {
                    res.status(200).json(mock.handler);
                }
                return;
            }
        }
        next();
    };
}
exports.createMockMiddleware = createMockMiddleware;
// TODO: cache
function getPathReAndKeys(path) {
    const keys = [];
    const re = (0, path_to_regexp_1.default)(path, keys);
    return { re, keys };
}
function decodeParam(val) {
    if (typeof val !== 'string' || val.length === 0) {
        return val;
    }
    try {
        return decodeURIComponent(val);
    }
    catch (err) {
        if (err instanceof URIError) {
            err.message = `Failed to decode param ' ${val} '`;
            // @ts-ignore
            err.status = 400;
            // @ts-ignore
            err.statusCode = 400;
        }
        throw err;
    }
}
