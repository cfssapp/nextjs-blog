"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMockData = void 0;
const esbuild_1 = __importDefault(require("@umijs/bundler-utils/compiled/esbuild"));
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const constants_1 = require("./constants");
function getMockData(opts) {
    utils_1.register.register({
        implementor: esbuild_1.default,
    });
    utils_1.register.clearFiles();
    function normalizeMockFile(file) {
        const cwd = opts.cwd.endsWith('/') ? opts.cwd : `${opts.cwd}/`;
        return utils_1.chalk.yellow(file.replace(cwd, ''));
    }
    const ret = [constants_1.MOCK_FILE_GLOB, ...(opts.mockConfig.include || [])]
        .reduce((memo, pattern) => {
        memo.push(...utils_1.glob.sync(pattern, { cwd: opts.cwd, ignore: ['**/*.d.ts'] }));
        return memo;
    }, [])
        .reduce((memo, file) => {
        const mockFile = `${opts.cwd}/${file}`;
        const m = require(mockFile);
        // Cannot convert undefined or null to object
        const obj = (m === null || m === void 0 ? void 0 : m.default) || {};
        for (const key of Object.keys(obj)) {
            const mock = getMock({ key, obj });
            mock.file = mockFile;
            // check conflict
            const id = `${mock.method} ${mock.path}`;
            (0, assert_1.default)(utils_1.lodash.isArray(mock.handler) ||
                utils_1.lodash.isPlainObject(mock.handler) ||
                typeof mock.handler === 'function', `Mock handler must be function or array or object, but got ${typeof mock.handler} for ${mock.method} in ${mock.file}`);
            if (memo[id]) {
                utils_1.logger.warn(`${id} is duplicated in ${normalizeMockFile(mockFile)} and ${normalizeMockFile(memo[id].file)}`);
            }
            memo[id] = mock;
        }
        return memo;
    }, {});
    for (const file of utils_1.register.getFiles()) {
        delete require.cache[file];
    }
    utils_1.register.restore();
    return ret;
}
exports.getMockData = getMockData;
function getMock(opts) {
    const { method, path } = parseKey(opts.key);
    const handler = opts.obj[opts.key];
    return { method, path, handler };
}
function parseKey(key) {
    const spliced = key.split(/\s+/);
    const len = spliced.length;
    if (len === 1) {
        return { method: constants_1.DEFAULT_METHOD, path: key };
    }
    else {
        const [method, path] = spliced;
        const upperCaseMethod = method.toUpperCase();
        (0, assert_1.default)(constants_1.VALID_METHODS.includes(upperCaseMethod), `method ${method} is not supported`);
        (0, assert_1.default)(path, `${key}, path is undefined`);
        return { method: upperCaseMethod, path };
    }
}
