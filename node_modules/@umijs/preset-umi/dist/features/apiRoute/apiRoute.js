"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@umijs/utils");
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const utils_2 = require("./utils");
const constants_1 = require("../../constants");
const constants_2 = require("./constants");
const esbuild_1 = __importDefault(require("./dev-server/esbuild"));
const esbuild_2 = __importDefault(require("./vercel/esbuild"));
const watch_1 = require("../../commands/dev/watch");
var ServerlessPlatform;
(function (ServerlessPlatform) {
    ServerlessPlatform["Vercel"] = "vercel";
    ServerlessPlatform["Netlify"] = "netlify";
    ServerlessPlatform["Worker"] = "worker";
})(ServerlessPlatform || (ServerlessPlatform = {}));
function getPlatform(p) {
    switch (p) {
        case 'vercel':
            return ServerlessPlatform.Vercel;
        case 'netlify':
            return ServerlessPlatform.Netlify;
        case 'worker':
            return ServerlessPlatform.Worker;
        default:
            return undefined;
    }
}
exports.default = (api) => {
    let platform;
    // 注册 API 路由相关配置项
    api.describe({
        key: 'apiRoute',
        config: {
            schema(Joi) {
                return Joi.object({
                    platform: Joi.string(),
                });
            },
        },
        enableBy: () => {
            const hasApiRoutes = fs_1.default.existsSync((0, path_1.join)(api.paths.absSrcPath, 'api'));
            if (!hasApiRoutes)
                return false;
            const config = api.userConfig.apiRoute;
            if (!config) {
                utils_1.logger.warn('Directory ./src/api exists, but config.apiRoute is not set. API route feature will not be enabled!');
                return false;
            }
            if (!config.platform) {
                utils_1.logger.warn('Please set config.apiRoute.platform to enable API route feature!');
                return false;
            }
            platform = getPlatform(config.platform);
            if (!platform) {
                utils_1.logger.warn('There is an invalid value of config.apiRoute.platform: ' +
                    config.platform +
                    ', so API route feature will not be enabled!');
                return false;
            }
            if (platform !== ServerlessPlatform.Vercel) {
                utils_1.logger.warn('Current version of Umi only supports deploying API routes to Vercel, so API route feature will not be enabled!');
                return false;
            }
            // 如果是 Vercel 平台，则需要检查是否有配置了 Vercel 配置
            if (!fs_1.default.existsSync((0, path_1.join)(api.paths.cwd, 'vercel.json'))) {
                utils_1.logger.warn('You have enabled the API route feature, but there is no vercel.json file in your work directory! ' +
                    'Automatically creating a vercel.json file ...');
                fs_1.default.writeFileSync((0, path_1.join)(api.paths.cwd, 'vercel.json'), JSON.stringify({ build: { env: { ENABLE_FILE_SYSTEM_API: '1' } } }, null, 2));
            }
            return true;
        },
    });
    // 生成中间产物时，将 API 路由与插件注册的中间件封装到临时文件目录下
    api.onGenerateFiles(() => __awaiter(void 0, void 0, void 0, function* () {
        // @TODO: 根据 platform 的值执行不同 Adapter 的流程
        const apiRoutes = Object.keys(api.appData.apiRoutes).map((k) => api.appData.apiRoutes[k]);
        apiRoutes.map((apiRoute) => {
            api.writeTmpFile({
                noPluginDir: true,
                path: (0, path_1.join)('api', apiRoute.file),
                tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'apiRoute.tpl'),
                context: {
                    adapterPath: (0, utils_1.winPath)((0, path_1.resolve)(__dirname, '../apiRoute/index.js')),
                    apiRootDirPath: (0, utils_1.winPath)((0, path_1.join)(api.paths.absTmpPath, 'api')),
                    handlerPath: (0, utils_1.winPath)((0, path_1.join)(api.paths.absSrcPath, 'api', apiRoute.file)),
                    apiRoutes: JSON.stringify(apiRoutes),
                },
            });
        });
        const middlewares = yield api.applyPlugins({
            key: 'addApiMiddlewares',
        });
        api.writeTmpFile({
            noPluginDir: true,
            path: 'api/_middlewares.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'middlewares.tpl'),
            context: { middlewares },
        });
    }));
    // 开发阶段，透过中间件拦截对 API 路由的请求，在这里直接进行处理
    api.addBeforeMiddlewares(() => [
        (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
            if (req.path.startsWith('/api')) {
                const path = req.path.replace('/api', '');
                const apiRoutes = Object.keys(api.appData.apiRoutes).map((k) => api.appData.apiRoutes[k]);
                const matchedApiRoute = (0, utils_2.matchApiRoute)(apiRoutes, path);
                if (!matchedApiRoute) {
                    utils_1.logger.warn(`404 - ${req.path}`);
                    next();
                    return;
                }
                yield require((0, path_1.join)(api.paths.cwd, constants_2.OUTPUT_PATH, matchedApiRoute.route.file).replace('.ts', '.js')).default(req, res);
                return;
            }
            next();
        }),
    ]);
    api.addTmpGenerateWatcherPaths(() => [api.paths.absApiRoutesPath]);
    // 编译时，将打包好的临时文件根据用户指定的目标平台进行打包
    api.onBeforeCompiler(() => __awaiter(void 0, void 0, void 0, function* () {
        // 当有新的 API 路由或是原有的路由被删除时，必须重启服务，因为 appData 内的 apiRoutes 没有更新
        if (api.env === 'development') {
            (0, watch_1.watch)({
                path: (0, path_1.join)(api.paths.absApiRoutesPath),
                addToUnWatches: true,
                onChange(e, p) {
                    if (e === 'add') {
                        utils_1.logger.event(`New API route ${(0, path_1.basename)(p)} detected, compiling ...`);
                        api.restartServer();
                        return;
                    }
                    if (e === 'unlink') {
                        utils_1.logger.event(`API route ${(0, path_1.basename)(p)} has been removed, compiling ...`);
                        api.restartServer();
                        return;
                    }
                },
            });
        }
        const apiRoutes = Object.keys(api.appData.apiRoutes).map((k) => api.appData.apiRoutes[k]);
        if (api.env === 'development') {
            yield (0, esbuild_1.default)(api, apiRoutes);
            return;
        }
        if (fs_1.default.existsSync((0, path_1.join)(api.paths.cwd, constants_2.OUTPUT_PATH))) {
            yield fs_1.default.rmdirSync((0, path_1.join)(api.paths.cwd, constants_2.OUTPUT_PATH), {
                recursive: true,
            });
        }
        switch (platform) {
            case ServerlessPlatform.Vercel:
                yield (0, esbuild_2.default)(api, apiRoutes);
                return;
            case ServerlessPlatform.Netlify:
                utils_1.logger.error('API routes bundle failed: Netlify is not supported yet!');
                return;
            case ServerlessPlatform.Worker:
                utils_1.logger.error('API routes bundle failed: Cloudflare Worker is not supported yet!');
                return;
            default:
                throw new Error(`API routes bundle failed: Unsupported platform: ${platform}`);
        }
    }));
};
