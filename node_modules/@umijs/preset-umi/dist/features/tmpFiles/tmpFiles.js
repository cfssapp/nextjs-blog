"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bundler_utils_1 = require("@umijs/bundler-utils");
const utils_1 = require("@umijs/utils");
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("../../constants");
const importsToStr_1 = require("./importsToStr");
const routes_1 = require("./routes");
exports.default = (api) => {
    api.describe({
        key: 'tmpFiles',
        config: {
            schema(Joi) {
                return Joi.boolean();
            },
        },
    });
    api.onGenerateFiles((opts) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const rendererPath = (0, utils_1.winPath)(yield api.applyPlugins({
            key: 'modifyRendererPath',
            initialValue: (0, path_1.dirname)(require.resolve('@umijs/renderer-react/package.json')),
        }));
        // umi.ts
        api.writeTmpFile({
            noPluginDir: true,
            path: 'umi.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'umi.tpl'),
            context: {
                mountElementId: api.config.mountElementId,
                rendererPath,
                entryCode: (yield api.applyPlugins({
                    key: 'addEntryCode',
                    initialValue: [],
                })).join('\n'),
                entryCodeAhead: (yield api.applyPlugins({
                    key: 'addEntryCodeAhead',
                    initialValue: [],
                })).join('\n'),
                polyfillImports: (0, importsToStr_1.importsToStr)(yield api.applyPlugins({
                    key: 'addPolyfillImports',
                    initialValue: [],
                })).join('\n'),
                importsAhead: (0, importsToStr_1.importsToStr)(yield api.applyPlugins({
                    key: 'addEntryImportsAhead',
                    initialValue: [
                        api.appData.globalCSS.length && {
                            source: api.appData.globalCSS[0],
                        },
                        api.appData.globalJS.length && {
                            source: api.appData.globalJS[0],
                        },
                    ].filter(Boolean),
                })).join('\n'),
                imports: (0, importsToStr_1.importsToStr)(yield api.applyPlugins({
                    key: 'addEntryImports',
                    initialValue: [],
                })).join('\n'),
                basename: api.config.base,
                historyType: api.config.history.type,
                loadingComponent: (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.tsx')) ||
                    (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.jsx')) ||
                    (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'loading.js')),
            },
        });
        // EmptyRoutes.tsx
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/EmptyRoute.tsx',
            content: `
import { Outlet } from 'umi';
export default function EmptyRoute() {
  return <Outlet />;
}
      `,
        });
        // route.ts
        let routes;
        if (opts.isFirstTime) {
            routes = api.appData.routes;
        }
        else {
            routes = yield (0, routes_1.getRoutes)({
                api,
            });
        }
        const hasSrc = api.appData.hasSrcDir;
        // @/pages/
        const pages = (0, path_1.basename)(((_a = api.config.conventionRoutes) === null || _a === void 0 ? void 0 : _a.base) || api.paths.absPagesPath);
        const prefix = hasSrc ? `../../../src/${pages}/` : `../../${pages}/`;
        const clonedRoutes = utils_1.lodash.cloneDeep(routes);
        for (const id of Object.keys(clonedRoutes)) {
            for (const key of Object.keys(clonedRoutes[id])) {
                if (key.startsWith('__') || key.startsWith('absPath')) {
                    delete clonedRoutes[id][key];
                }
            }
        }
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/route.tsx',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'route.tpl'),
            context: {
                routes: JSON.stringify(clonedRoutes),
                routeComponents: yield (0, routes_1.getRouteComponents)({ routes, prefix }),
            },
        });
        // plugin.ts
        const plugins = yield api.applyPlugins({
            key: 'addRuntimePlugin',
            initialValue: [
                // TODO: add tryFiles in @umijs/utils
                (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'app.ts')) &&
                    (0, path_1.join)(api.paths.absSrcPath, 'app.ts'),
                (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'app.tsx')) &&
                    (0, path_1.join)(api.paths.absSrcPath, 'app.tsx'),
                (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'app.jsx')) &&
                    (0, path_1.join)(api.paths.absSrcPath, 'app.jsx'),
                (0, fs_1.existsSync)((0, path_1.join)(api.paths.absSrcPath, 'app.js')) &&
                    (0, path_1.join)(api.paths.absSrcPath, 'app.js'),
            ]
                .filter(Boolean)
                .slice(0, 1),
        });
        const validKeys = yield api.applyPlugins({
            key: 'addRuntimePluginKey',
            initialValue: [
                // TODO: support these methods
                // 'modifyClientRenderOpts',
                'patchRoutes',
                'rootContainer',
                'innerProvider',
                'i18nProvider',
                'accessProvider',
                'dataflowProvider',
                'outerProvider',
                'render',
                'onRouteChange',
            ],
        });
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/plugin.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'plugin.tpl'),
            context: {
                plugins: plugins.map((plugin, index) => ({
                    index,
                    path: (0, utils_1.winPath)(plugin),
                })),
                validKeys: validKeys,
            },
        });
        // history.ts
        api.writeTmpFile({
            noPluginDir: true,
            path: 'core/history.ts',
            tplPath: (0, path_1.join)(constants_1.TEMPLATES_DIR, 'history.tpl'),
            context: {
                rendererPath,
            },
        });
    }));
    function getExports(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = (0, fs_1.readFileSync)(opts.path, 'utf-8');
            const [_, exports] = yield (0, bundler_utils_1.parseModule)({ content, path: opts.path });
            return exports || [];
        });
    }
    function checkMembers(opts) {
        const conflicts = utils_1.lodash.intersection(opts.exportMembers, opts.members);
        if (conflicts.length) {
            throw new Error(`Conflict members: ${conflicts.join(', ')} in ${opts.path}`);
        }
    }
    function getExportsAndCheck(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const members = (yield getExports(opts));
            checkMembers({
                members,
                exportMembers: opts.exportMembers,
                path: opts.path,
            });
            opts.exportMembers.push(...members);
            return members;
        });
    }
    // Generate @@/exports.ts
    api.register({
        key: 'onGenerateFiles',
        fn: () => __awaiter(void 0, void 0, void 0, function* () {
            const exports = [];
            const exportMembers = ['default'];
            // @umijs/renderer-react
            exports.push('// @umijs/renderer-react');
            const rendererReactPath = (0, utils_1.winPath)((0, path_1.dirname)(require.resolve('@umijs/renderer-react/package.json')));
            exports.push(`export { ${(yield getExportsAndCheck({
                path: (0, path_1.join)(rendererReactPath, 'dist/index.js'),
                exportMembers,
            })).join(', ')} } from '${rendererReactPath}';`);
            // umi/client/client/plugin
            exports.push('// umi/client/client/plugin');
            const umiDir = process.env.UMI_DIR;
            const umiPluginPath = (0, utils_1.winPath)((0, path_1.join)(umiDir, 'client/client/plugin.js'));
            exports.push(`export { ${(yield getExportsAndCheck({
                path: umiPluginPath,
                exportMembers,
            })).join(', ')} } from '${umiPluginPath}';`);
            // @@/core/history.ts
            exports.push(`export { history, createHistory } from './core/history';`);
            checkMembers({
                members: ['history', 'createHistory'],
                exportMembers,
                path: '@@/core/history.ts',
            });
            // plugins
            exports.push('// plugins');
            const plugins = (0, fs_1.readdirSync)(api.paths.absTmpPath).filter((file) => {
                if (file.startsWith('plugin-') &&
                    ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, file, 'index.ts')) ||
                        (0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, file, 'index.tsx')))) {
                    return true;
                }
            });
            for (const plugin of plugins) {
                let file;
                if ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, plugin, 'index.ts'))) {
                    file = (0, path_1.join)(api.paths.absTmpPath, plugin, 'index.ts');
                }
                if ((0, fs_1.existsSync)((0, path_1.join)(api.paths.absTmpPath, plugin, 'index.tsx'))) {
                    file = (0, path_1.join)(api.paths.absTmpPath, plugin, 'index.tsx');
                }
                const pluginExports = yield getExportsAndCheck({
                    path: file,
                    exportMembers,
                });
                if (pluginExports.length) {
                    exports.push(`export { ${pluginExports.join(', ')} } from '${(0, utils_1.winPath)((0, path_1.join)(api.paths.absTmpPath, plugin))}';`);
                }
            }
            // plugins types.ts
            exports.push('// plugins types.d.ts');
            for (const plugin of plugins) {
                const file = (0, utils_1.winPath)((0, path_1.join)(api.paths.absTmpPath, plugin, 'types.d.ts'));
                if ((0, fs_1.existsSync)(file)) {
                    exports.push(`export * from '${file}';`);
                }
            }
            api.writeTmpFile({
                noPluginDir: true,
                path: 'exports.ts',
                content: exports.join('\n'),
            });
        }),
        stage: Infinity,
    });
};
