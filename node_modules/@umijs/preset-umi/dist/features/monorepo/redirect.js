"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const get_packages_1 = require("../../../compiled/@manypkg/get-packages");
const utils_1 = require("@umijs/utils");
const pkg_up_1 = require("@umijs/utils/compiled/pkg-up");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = require("path");
exports.default = (api) => {
    api.describe({
        key: 'monorepoRedirect',
        config: {
            schema(Joi) {
                return Joi.alternatives(Joi.boolean(), Joi.object({
                    srcDir: Joi.array().items(Joi.string()),
                    exclude: Joi.array().items(Joi.object().instance(RegExp)),
                }));
            },
        },
        enableBy: api.EnableBy.config,
    });
    api.modifyConfig((memo) => __awaiter(void 0, void 0, void 0, function* () {
        const rootPkg = yield (0, pkg_up_1.pkgUp)({ cwd: (0, path_1.dirname)(api.cwd) });
        if (!rootPkg)
            return memo;
        const root = (0, path_1.dirname)(rootPkg);
        (0, assert_1.default)(isMonorepo({ root }), `The 'monorepoRedirect' option can only be used in monorepo, you don't need configure.`);
        const config = memo.monorepoRedirect || {};
        const { exclude = [], srcDir = ['src'] } = config;
        // Note: not match `umi` package in local dev
        if (__filename.includes(`packages/preset-umi`)) {
            utils_1.logger.info(`[monorepoRedirect]: Auto excluded 'umi' package in local dev scene`);
            exclude.push(/^umi$/);
        }
        // collect use workspace deps
        const usingDeps = collectPkgDeps(api.pkg).filter((name) => {
            return !exclude.some((reg) => reg.test(name));
        });
        if (!usingDeps.length)
            return memo;
        // collect all project
        const projects = yield collectAllProjects({ root });
        const alias = usingDeps.reduce((obj, name) => {
            const root = projects[name];
            if (!root) {
                return obj;
            }
            srcDir.some((dirName) => {
                const dirPath = (0, path_1.join)(root, dirName);
                if ((0, fs_1.existsSync)(dirPath) && (0, fs_1.statSync)(dirPath).isDirectory()) {
                    // redirect to source dir
                    obj[name] = dirPath;
                    return true;
                }
            });
            return obj;
        }, {});
        memo.alias = Object.assign(Object.assign({}, memo.alias), alias);
        return memo;
    }));
};
const DEP_KEYS = ['devDependencies', 'dependencies'];
function collectPkgDeps(pkg) {
    const deps = [];
    DEP_KEYS.forEach((type) => {
        deps.push(...Object.keys((pkg === null || pkg === void 0 ? void 0 : pkg[type]) || {}));
    });
    return deps;
}
function collectAllProjects(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspaces = yield (0, get_packages_1.getPackages)(opts.root);
        return workspaces.packages.reduce((obj, pkg) => {
            var _a;
            const name = (_a = pkg.packageJson) === null || _a === void 0 ? void 0 : _a.name;
            if (name) {
                obj[name] = pkg.dir;
            }
            return obj;
        }, {});
    });
}
const MONOREPO_FILE = ['pnpm-workspace.yaml', 'lerna.json'];
function isMonorepo(opts) {
    const pkgExist = (0, fs_1.existsSync)((0, path_1.join)(opts.root, 'package.json'));
    return (pkgExist &&
        MONOREPO_FILE.some((file) => {
            return (0, fs_1.existsSync)((0, path_1.join)(opts.root, file));
        }));
}
