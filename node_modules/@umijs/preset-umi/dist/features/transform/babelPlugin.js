"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const t = __importStar(require("@umijs/bundler-utils/compiled/babel/types"));
const utils_1 = require("@umijs/utils");
const path_1 = require("path");
function isModuleExports(node) {
    return (t.isMemberExpression(node) &&
        t.isIdentifier(node.object, { name: 'module' }) &&
        t.isIdentifier(node.property, { name: 'exports' }));
}
function isExportsMemberExpression(node) {
    return (t.isMemberExpression(node) &&
        t.isIdentifier(node.object, { name: 'exports' }));
}
function default_1() {
    let opts;
    return {
        pre() {
            // @ts-ignore
            this.cache = new Map();
        },
        post(state) {
            // @ts-ignore
            const { cache } = this;
            const filename = (0, utils_1.winPath)(state.opts.filename);
            if (cache.has(filename) &&
                !filename.includes('bundler-webpack/client') &&
                !filename.startsWith((0, utils_1.winPath)((0, path_1.join)(opts.cwd, 'node_modules')))) {
                opts.onCheckCode({
                    args: Object.assign(Object.assign({}, cache.get(state.opts.filename)), { file: state.opts.filename, isFromTmp: state.opts.filename.startsWith(opts.absTmpPath) }),
                });
            }
        },
        visitor: {
            Program: {
                enter(path, state) {
                    opts = state.opts;
                    // @ts-ignore
                    const file = path === null || path === void 0 ? void 0 : path.hub.file.opts.filename;
                    // @ts-ignore
                    const cache = this.cache;
                    // reset cache
                    cache.set(file, {
                        code: path.hub.getCode(),
                        imports: [],
                        cjsExports: [],
                    });
                    path.node.body.forEach((node) => {
                        // import x from 'x'; { default: 'x' }
                        // import * as x2 from 'x'; { namespace: 'x2' }
                        // import x3, * as xx from 'x'; { default: 'x3', namespace: 'xx' }
                        // import { x4, a as b } from 'x'; { specifiers: { x4: 'x4', a: 'b' } }
                        if (t.isImportDeclaration(node)) {
                            const ret = {
                                source: node.source.value,
                                loc: node.loc,
                            };
                            node.specifiers.forEach((specifier) => {
                                if (t.isImportDefaultSpecifier(specifier)) {
                                    ret.default = specifier.local.name;
                                }
                                else if (t.isImportNamespaceSpecifier(specifier)) {
                                    ret.namespace = specifier.local.name;
                                }
                                else if (t.isImportSpecifier(specifier)) {
                                    ret.specifiers || (ret.specifiers = {});
                                    ret.specifiers[t.isIdentifier(specifier.imported)
                                        ? specifier.imported.name
                                        : specifier.imported.value] = specifier.local.name;
                                }
                            });
                            cache.get(file).imports.push(ret);
                        }
                        if (t.isExpressionStatement(node)) {
                            const n = node;
                            // module.exports = x;
                            if (t.isAssignmentExpression(n.expression) &&
                                isModuleExports(n.expression.left)) {
                                cache.get(file).cjsExports.push('default');
                            }
                            // exports.x = x;
                            if (t.isAssignmentExpression(n.expression) &&
                                isExportsMemberExpression(n.expression.left)) {
                                cache.get(file).cjsExports.push(
                                // @ts-ignore
                                n.expression.left.property.name);
                            }
                        }
                        // TODO:
                        // exports
                        // callExpression
                        // newExpression
                    });
                },
            },
        },
    };
}
exports.default = default_1;
