"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const es_module_lexer_1 = require("@umijs/bundler-utils/compiled/es-module-lexer");
const magic_string_1 = __importDefault(require("magic-string"));
const path_1 = require("path");
const scan_1 = require("../../libs/scan");
const requireToImport_1 = __importDefault(require("./esbuildPlugins/requireToImport"));
const topLevelExternal_1 = __importDefault(require("./esbuildPlugins/topLevelExternal"));
const Service_1 = __importDefault(require("./Service"));
let importmap = { imports: {}, scopes: {} };
let importmatches = {};
/**
 * esmi vite plugin
 */
function esmi(opts) {
    return {
        name: 'preset-umi:esmi',
        configResolved(config) {
            var _a, _b;
            var _c, _d;
            const { include, exclude } = config.optimizeDeps;
            (_a = (_c = config.optimizeDeps).include) !== null && _a !== void 0 ? _a : (_c.include = []);
            // do not pre-compile deps which will be loaded by importmap (for top-level deps)
            if (include === null || include === void 0 ? void 0 : include.length) {
                config.optimizeDeps.include = include.filter((item) => !importmatches[item] && !importmap.imports[item]);
            }
            // exclude pre-compile deps
            config.optimizeDeps.exclude = [
                ...new Set([
                    // deps from user config
                    ...(exclude || []),
                    // deps from local scan
                    ...Object.keys(importmatches),
                    // deps from esmi analyze result
                    ...Object.keys(importmap.imports),
                ]),
            ];
            // apply esbuild plugins
            (_b = (_d = config.optimizeDeps).esbuildOptions) !== null && _b !== void 0 ? _b : (_d.esbuildOptions = {});
            // @ts-ignore
            config.optimizeDeps.esbuildOptions.plugins = [
                // transform require call to import
                (0, requireToImport_1.default)({ exclude: config.optimizeDeps.exclude }),
                // make sure vite only external top-level npm imports, and resolve sub-path npm imports
                (0, topLevelExternal_1.default)({
                    exclude: config.optimizeDeps.exclude,
                    resolver: opts.resolver,
                }),
                // @ts-ignore
            ].concat(config.optimizeDeps.esbuildOptions.plugins || []);
        },
        transform(source) {
            try {
                // parse imports
                const imports = (0, es_module_lexer_1.parse)(source)[0];
                let s;
                // process all imports
                imports.forEach((item) => {
                    const { n: specifier, s: start, e: end } = item;
                    // replace npm package to CDN url for matched imports
                    if (specifier) {
                        const replacement = 
                        // search from local scan matches first (for alias)
                        (importmatches[specifier] &&
                            importmap.imports[importmatches[specifier]]) ||
                            // search from esmi analyze result
                            importmap.imports[specifier];
                        if (replacement) {
                            s !== null && s !== void 0 ? s : (s = new magic_string_1.default(source));
                            s.overwrite(start, end, replacement);
                        }
                    }
                });
                return (s === null || s === void 0 ? void 0 : s.toString()) || source;
            }
            catch (_a) {
                // syntax error or non-javascript files
                return null;
            }
        },
        handleHotUpdate(ctx) {
            return opts.handleHotUpdate(ctx);
        },
    };
}
/**
 * generate package data
 * @param api   plugin api
 */
function generatePkgData(api) {
    return {
        pkgJsonContent: {
            dependencies: api.pkg.dependencies || {},
            devDependencies: api.pkg.devDependencies || {},
        },
        pkgInfo: {
            name: api.pkg.name,
            version: api.pkg.version,
            type: 'esm',
            exports: [
                {
                    name: 'default',
                    path: 'es/index.js',
                    from: '',
                    deps: Object.entries(api.appData.deps)
                        // only compile entry imports
                        .filter(([_, { matches }]) => matches.length)
                        // convert to esmi config
                        .map(([name, { version }]) => ({
                        name,
                        version,
                        usedMap: {
                            [name]: { usedNamespace: true, usedNames: [] },
                        },
                    })),
                },
            ],
            assets: [],
        },
    };
}
exports.default = (api) => {
    let service;
    let resolver;
    /**
     * refresh importmap and save to the top-level variable
     */
    function refreshImportMap() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // scan and module graph
            // TODO: module graph
            yield api.applyPlugins({
                key: 'updateAppDataDeps',
                type: api.ApplyPluginsType.event,
            });
            // skip umi by default
            delete api.appData.deps['umi'];
            const data = generatePkgData(api);
            const deps = data.pkgInfo.exports.reduce((r, exp) => r.concat(exp.deps.map((dep) => dep.name)), []);
            const hasNewDep = deps.some((i) => !importmap.imports[i]);
            // update importmap from esm if there has new import
            if (hasNewDep) {
                importmap = (_a = (yield service.getImportmap(data))) === null || _a === void 0 ? void 0 : _a.importMap;
                // update matches map to dep name
                importmatches = Object.keys(api.appData.deps).reduce((r, dep) => {
                    // filter subpath imports
                    if (!api.appData.deps[dep].subpaths.length) {
                        // map all matches to dep name
                        api.appData.deps[dep].matches.forEach((m) => {
                            r[m] = dep;
                        });
                    }
                    return r;
                }, {});
                // because we will replaced package name to CDN url in vite plugin
                // so we must append scope rules for the CDN url like the import specifier
                // example:
                //   origin:
                //   { imports: { a: 'aa', b: 'bb', c: 'cc1' }, scopes: { b: { c: 'cc2' } } }
                //   to:
                //   { imports: { a: 'aa', b: 'bb', c: 'cc1' }, scopes: { b: { c: 'cc2' }, 'bb': { c: 'cc2' } } }
                Object.keys(importmap.scopes || {})
                    .filter((item) => importmap.imports[item])
                    .forEach((item) => {
                    importmap.scopes[importmap.imports[item]] = importmap.scopes[item];
                });
            }
        });
    }
    // describe config
    api.describe({
        key: 'esmi',
        config: {
            schema(Joi) {
                return Joi.object({
                    cdnOrigin: Joi.string(),
                    shimUrl: Joi.string(),
                });
            },
        },
        enableBy: api.EnableBy.config,
    });
    // check bundler type
    api.onStart(() => {
        if (!api.config.vite) {
            throw new Error(`esmi can only be used in vite mode.`);
        }
    });
    // collect all imports after tmp files generated
    api.onBeforeCompiler(() => __awaiter(void 0, void 0, void 0, function* () {
        if (api.config.vite) {
            // init esmi service
            service = new Service_1.default({
                cdnOrigin: api.config.esmi.cdnOrigin,
                cacheDir: (0, path_1.join)(api.cwd, '.esmi'),
            });
            // init project resolver
            resolver = (0, scan_1.createResolver)({
                alias: api.config.alias,
            });
            // init importmap
            yield refreshImportMap();
        }
    }));
    // append ipmortmap script for HTML
    api.modifyHTML(($) => {
        const scp = $('<script type="importmap"></script>\n');
        scp.html(JSON.stringify(importmap, null, 2));
        $('head > script:eq(0)').before(scp);
        // append importmap shim script
        if (api.config.esmi.shimUrl) {
            $('body > script:eq(0)').before($(`<script src="${api.config.esmi.shimUrl}"></script>\n`));
        }
        // preload for importmap modules
        Object.values(importmap.imports).forEach((url) => {
            scp.before($(`<link rel="modulepreload" href="${url}" />\n`));
        });
        return $;
    });
    if (api.config.vite) {
        // apply esmi vite plugin
        api.modifyViteConfig((memo) => {
            memo.plugins = (memo.plugins || []).concat(esmi({
                handleHotUpdate: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                    ctx.file;
                    // TODO: incremental refresh by ctx.file
                    yield refreshImportMap();
                    // TODO: refresh page when importmap changed
                }),
                resolver,
            }));
            return memo;
        });
    }
    else {
        // TODO: webpack implementation
    }
};
