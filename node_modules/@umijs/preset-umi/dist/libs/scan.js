"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scan = exports.createResolver = exports.getContent = exports.scanContent = void 0;
const bundler_utils_1 = require("@umijs/bundler-utils");
const es_module_lexer_1 = require("@umijs/bundler-utils/compiled/es-module-lexer");
const esbuild_1 = require("@umijs/bundler-utils/compiled/esbuild");
const utils_1 = require("@umijs/utils");
const assert_1 = __importDefault(require("assert"));
const enhanced_resolve_1 = __importDefault(require("enhanced-resolve"));
const fs_1 = require("fs");
const path_1 = require("path");
var ImportType;
(function (ImportType) {
    ImportType["import"] = "import";
    ImportType["dynamicImport"] = "dynamicImport";
    ImportType["export"] = "export";
})(ImportType || (ImportType = {}));
// 项目文件都是 esm，无需考虑 cjs
function scanContent(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        yield es_module_lexer_1.init;
        const [imports] = (0, es_module_lexer_1.parse)(opts.content);
        const deps = imports
            .filter(
        // exclude all type-only deps
        (imp) => {
            const stmt = opts.content.slice(imp.ss, imp.se);
            return (
            // skip dynamicImport
            imp.d > -1 ||
                // import a from or import a,
                /^import\s+[a-zA-Z_$][\w_$]*(\s+from|\s*,)/.test(stmt) ||
                // export a from or export *
                /^export\s+([a-zA-Z_$][\w_$]*\s+from|\*)/.test(stmt) ||
                // { a, type b } or { type a, b }
                /(?<!type\s+){(\s*(?!type)[a-zA-Z_$]|.*,\s*(?!type)[a-zA-Z_$])/.test(stmt));
        })
            .map((imp) => {
            let importType = ImportType.import;
            if (imp.d > -1)
                importType = ImportType.dynamicImport;
            if (opts.content.slice(imp.ss, imp.se).startsWith('export ')) {
                importType = ImportType.export;
            }
            return {
                url: imp.n,
                importType,
            };
        });
        return { deps };
    });
}
exports.scanContent = scanContent;
function getContent(path) {
    return __awaiter(this, void 0, void 0, function* () {
        let content = (0, fs_1.readFileSync)(path, 'utf-8');
        // es-module-lexer don't support jsx
        if (path.endsWith('.tsx') || path.endsWith('.jsx')) {
            content = (0, esbuild_1.transformSync)(content, {
                loader: (0, path_1.extname)(path).slice(1),
                format: 'esm',
            }).code;
        }
        return content;
    });
}
exports.getContent = getContent;
function createResolver(opts) {
    const resolver = enhanced_resolve_1.default.create({
        mainFields: ['module', 'browser', 'main'],
        extensions: ['.js', '.json', '.mjs', '.ts', '.tsx'],
        exportsFields: [],
        alias: opts.alias,
    });
    function resolve(context, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                resolver(context, path, (err, result) => err ? reject(err) : resolve(result));
            });
        });
    }
    return { resolve };
}
exports.createResolver = createResolver;
function scan(opts) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const cache = new Map();
        const queueDeps = [opts.entry];
        const ret = {};
        while (queueDeps.length) {
            const depPath = queueDeps.shift();
            if (cache.has(depPath))
                continue;
            // TODO: use parseModule in bundler-utils
            const content = yield getContent(depPath);
            const { deps } = yield scanContent({ content });
            cache.set(depPath, deps);
            for (const dep of deps) {
                // skip resolve external deps
                if ((_a = opts.externals) === null || _a === void 0 ? void 0 : _a[dep.url]) {
                    ret[dep.url] = {
                        version: '',
                        matches: [],
                        subpaths: [],
                        external: true,
                    };
                    continue;
                }
                const resolved = yield opts.resolver.resolve((0, path_1.dirname)(depPath), dep.url);
                if ((0, bundler_utils_1.isDepPath)(resolved)) {
                    const pkgPath = utils_1.pkgUp.pkgUpSync({ cwd: resolved });
                    (0, assert_1.default)(pkgPath, `package.json for found for ${resolved}`);
                    const pkg = require(pkgPath);
                    const entryResolved = yield opts.resolver
                        .resolve((0, path_1.dirname)(pkgPath), '.')
                        // alias may resolve error (eg: dva from @umijs/plugins)
                        // fallback to null for mark it as subpath usage
                        .catch(() => null);
                    const isSubpath = entryResolved !== resolved;
                    ret[pkg.name] = {
                        version: pkg.version,
                        // collect entry matches
                        matches: [
                            // avoid duplicate
                            ...new Set([
                                ...(((_b = ret[pkg.name]) === null || _b === void 0 ? void 0 : _b.matches) || []),
                                // only collect non-subpath matches
                                ...(!isSubpath
                                    ? [
                                        // match origin path from source code
                                        dep.url,
                                        // match resolved absolute path
                                        resolved,
                                        // match no ext name path
                                        resolved.replace(/\/\.[^\.]+$/, ''),
                                        // match parent dir for index module
                                        ...(/\/index[^\/]+$/.test(resolved)
                                            ? [(0, path_1.dirname)(resolved)]
                                            : []),
                                    ]
                                    : []),
                            ]),
                        ],
                        // collect subpath matches
                        subpaths: [
                            // avoid duplicate
                            ...new Set([
                                ...(((_c = ret[pkg.name]) === null || _c === void 0 ? void 0 : _c.subpaths) || []),
                                ...(isSubpath ? [dep.url] : []),
                            ]),
                        ],
                    };
                }
                else if (['.ts', '.tsx', '.js', '.jsx', '.mjs'].includes((0, path_1.extname)(resolved))) {
                    queueDeps.push(resolved);
                }
            }
        }
        return ret;
    });
}
exports.scan = scan;
